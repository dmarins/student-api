
================================================================================
File: .code_quality/.golangci.yml
Size: 975 B
================================================================================

issues:
  new-from-rev: ""  # Leave this empty or set a specific revision to check for issues since that point
run:
  timeout: 5m  # Maximum time allowed for the linter to run
  modules-download-mode: readonly  # Prevents downloading new modules, only uses what's already in the Go mod cache
linters:
  disable-all: true  # Disables all linters by default
  enable:
    - gofmt        # Ensures the code is formatted according to Go standards
    - goimports    # Similar to gofmt but also fixes and organizes imports
    - govet        # Catches potential code issues like suspicious behavior or common pitfalls
    - gocyclo      # Checks for cyclomatic complexity, ensuring functions are not overly complex
    - staticcheck  # Performs advanced static analysis and finds bugs or unused code
    - ineffassign  # Detects ineffective assignments (variables assigned but never used)
    - errcheck     # Ensures errors are properly handled, avoiding unnoticed error returns


================================================================================
File: .env
Size: 279 B
================================================================================

POSTGRES_HOST=db
POSTGRES_PORT=5432
POSTGRES_USER=root
POSTGRES_PASSWORD=root
POSTGRES_DB=students

APP_NAME=student-api
APP_HOST=0.0.0.0
APP_PORT=8080
APP_GRACEFUL_SHUTDOWN_TIMEOUT=15s

HEADER_CID=x-cid
HEADER_TENANT=x-tenant

REQUEST_CONTEXT=requestContext
REQUEST_TIMEOUT=10s


================================================================================
File: .env.local
Size: 288 B
================================================================================

POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=root
POSTGRES_PASSWORD=root
POSTGRES_DB=students

APP_NAME=student-api
APP_HOST=localhost
APP_PORT=8080
APP_GRACEFUL_SHUTDOWN_TIMEOUT=5s

HEADER_CID=x-cid
HEADER_TENANT=x-tenant

REQUEST_CONTEXT=requestContext
REQUEST_TIMEOUT=180s


================================================================================
File: .gitignore
Size: 490 B
================================================================================

# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum


================================================================================
File: .pre-commit-config.yaml
Size: 489 B
================================================================================

repos:
  - repo: https://github.com/macisamuele/language-formatters-pre-commit-hooks
    rev: v2.3.0
    hooks:
      - id: pretty-format-golang
        args:
          - --autofix
  - repo: https://github.com/golangci/golangci-lint
    rev: v1.61.0
    hooks:
      - id: golangci-lint
        entry: golangci-lint run
        args:
          - --allow-parallel-runners
          - --max-issues-per-linter=0
          - --max-same-issues=0
          - --config=.code_quality/.golangci.yml

================================================================================
File: .requests/healthcheck.http
Size: 45 B
================================================================================

### success

GET http://localhost:8080/health

================================================================================
File: .requests/student_create.http
Size: 680 B
================================================================================

### missing header

POST http://localhost:8080/v1/students
Content-Type: application/json

{
    "name": "student {{$randomInt 1 100}}"
}

### success

POST http://localhost:8080/v1/students
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": "student {{$randomInt 1 100}}"
}

### invalid payload

POST http://localhost:8080/v1/students
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": 1
}

### required field

POST http://localhost:8080/v1/students
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": ""
}

### same name

POST http://localhost:8080/v1/students
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": "bob"
}

================================================================================
File: .requests/student_delete.http
Size: 403 B
================================================================================

### missing header

DELETE http://localhost:8080/v1/students/8e99273f-e566-4476-836e-048b1ecd9c4d

### success

DELETE http://localhost:8080/v1/students/8e99273f-e566-4476-836e-048b1ecd9c4d
x-tenant: {{$guid}}

### invalid id

DELETE http://localhost:8080/v1/students/1
x-tenant: {{$guid}}

### not found

DELETE http://localhost:8080/v1/students/8e99273f-e566-4476-836e-048b1ecd9999
x-tenant: {{$guid}}

================================================================================
File: .requests/student_read.http
Size: 391 B
================================================================================

### missing header

GET http://localhost:8080/v1/students/06b2ec25-3fe0-475e-9077-e77a113f4727

### success

GET http://localhost:8080/v1/students/06b2ec25-3fe0-475e-9077-e77a113f4727
x-tenant: {{$guid}}

### not found

GET http://localhost:8080/v1/students/06b2ec25-3fe0-475e-9077-e77a113f4999
x-tenant: {{$guid}}

### invalid id

GET http://localhost:8080/v1/students/1
x-tenant: {{$guid}}

================================================================================
File: .requests/student_search.http
Size: 806 B
================================================================================

### missing header

GET http://localhost:8080/v1/students?page=1&pageSize=10

### success

GET http://localhost:8080/v1/students
x-tenant: {{$guid}}

### success with filter

GET http://localhost:8080/v1/students?name=thompson
x-tenant: {{$guid}}

### success with explicit pagination

GET http://localhost:8080/v1/students?page=1&pageSize=3
x-tenant: {{$guid}}

### success with explicit pagination

GET http://localhost:8080/v1/students?page=3&pageSize=1&name=thompson
x-tenant: {{$guid}}

### success with complete pagination

GET http://localhost:8080/v1/students?page=1&pageSize=10&sortOrder=desc&sortField=name
x-tenant: {{$guid}}

### success with complete pagination and filter

GET http://localhost:8080/v1/students?page=1&pageSize=10&sortOrder=asc&sortField=name&name=thompson
x-tenant: {{$guid}}

================================================================================
File: .requests/student_update.http
Size: 870 B
================================================================================

### missing header

PUT http://localhost:8080/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893
Content-Type: application/json

{
    "name": "john updated {{$randomInt 1 100}}"
}

### success

PUT http://localhost:8080/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": "john updated {{$randomInt 1 100}}"
}

### invalid payload

PUT http://localhost:8080/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": 1
}

### required field

PUT http://localhost:8080/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": ""
}

### same name

PUT http://localhost:8080/v1/students/bcff9f56-1ba6-4f92-9478-635c3f18e558
x-tenant: {{$guid}}
Content-Type: application/json

{
    "name": "bob"
}

================================================================================
File: .vscode/launch.json
Size: 393 B
================================================================================

{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "local debug",
            "type": "go",
            "request": "launch",
            "mode": "debug",
            "program": "${workspaceRoot}/cmd/main.go",
            "cwd": "${workspaceRoot}",
            "env": {
                "APP_ENV": "local"
            },
            "showLog": true
        }
    ]
}

================================================================================
File: .vscode/tasks.json
Size: 334 B
================================================================================

{
    "version": "2.0.0",
    "tasks": [
      {
        "label": "Run Pre-commit",
        "type": "shell",
        "command": "pre-commit run --all-files",
        "group": {
          "kind": "build",
          "isDefault": true
        },
        "problemMatcher": [],
        "detail": "Run pre-commit hooks"
      }
    ]
  }
  

================================================================================
File: Dockerfile
Size: 400 B
================================================================================

FROM golang:1.23 AS builder
WORKDIR /app
# RUN apt-get install -y ca-certificates
COPY . .
RUN go mod download
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o students-api cmd/main.go

FROM scratch AS runner
# COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /app/.env .
COPY --from=builder /app/students-api .
EXPOSE 8080
ENTRYPOINT ["./students-api"]

================================================================================
File: Makefile
Size: 3.16 kB
================================================================================

DOCKERCOMPOSECMD=docker-compose
GOCMD=go
DOCKERCMD=docker
GOBIN=$(shell $(GOCMD) env GOPATH)/bin

.PHONY: down local-up local-restart docker-up docker-restart download run pgquery mockgen-download mocks-clean mocks-gen tests-clean tests tests-coverage openapi-download openapi-gen

down:
	$(DOCKERCOMPOSECMD) down --remove-orphans

local-up:
	$(DOCKERCOMPOSECMD) -f docker-compose.local.yaml up -d
	@echo "Waiting until Postgres be ready..."
	@until docker ps | grep db | grep "(healthy)"; do sleep 1; done
	@echo "Postgres is started."

local-restart: down local-up

docker-up:
	$(DOCKERCOMPOSECMD) -f docker-compose.yaml up -d --build
	@echo "Waiting until Postgres be ready..."
	@until docker ps | grep db | grep "(healthy)"; do sleep 1; done
	@echo "Postgres is started."

docker-restart: down docker-up

download:
	$(GOCMD) mod download

run: download
	APP_ENV=local $(GOCMD) run ./cmd/main.go

pgquery:
	$(DOCKERCMD) exec -it db psql -U root -h localhost -d students -p 5432

mockgen-download: download
	$(GOCMD) install -mod=mod go.uber.org/mock/mockgen@latest

mocks-clean:
	@echo "CLEANING MOCKS START..."
	rm -rf internal/domain/mocks/*
	@echo "CLEAN MOCKS!"

mocks-gen: mockgen-download mocks-clean
	$(GOBIN)/mockgen -source=internal/infrastructure/logger/logger.go -destination=internal/domain/mocks/logger.go -typed=true -package=mocks	
	$(GOBIN)/mockgen -source=internal/infrastructure/tracer/tracer.go -destination=internal/domain/mocks/tracer.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/infrastructure/tracer/span_wrapper.go -destination=internal/domain/mocks/span_wrapper.go -typed=true -package=mocks 
	$(GOBIN)/mockgen -source=internal/domain/repositories/healthcheck_repository.go -destination=internal/domain/mocks/healthcheck_repository.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/domain/repositories/student_repository.go -destination=internal/domain/mocks/student_repository.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/domain/usecases/healthcheck.go -destination=internal/domain/mocks/healthcheck.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/domain/usecases/student_create.go -destination=internal/domain/mocks/student_create.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/domain/usecases/student_read.go -destination=internal/domain/mocks/student_read.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/domain/usecases/student_update.go -destination=internal/domain/mocks/student_update.go -typed=true -package=mocks
	$(GOBIN)/mockgen -source=internal/domain/usecases/student_delete.go -destination=internal/domain/mocks/student_delete.go -typed=true -package=mocks

tests-clean:
	$(GOCMD) clean -testcache

tests: tests-clean local-restart
	$(GOCMD) test -cover -p=1 ./...

tests-coverage: tests-clean
	$(GOCMD) test -cover -p=1 -covermode=count -coverprofile=coverage.out ./...
	$(GOCMD) tool cover -html=coverage.out

openapi-download:
	$(GOCMD) mod download
	$(GOCMD) install github.com/swaggo/swag/cmd/swag@latest

openapi-gen: openapi-download
	$(GOBIN)/swag init -g cmd/main.go -o docs/openapi
	$(GOBIN)/swag fmt

================================================================================
File: README.md
Size: 4.16 kB
================================================================================

<h1 align="center">student-api</h1>

<div align="center">

This microservice was developed in Go, implementing the best practices of the RESTful standard. It offers a robust and efficient API, with endpoints that support full CRUD (Create, Read, Update and Delete) operations.

[![Go Version](https://img.shields.io/badge/Go-1.23.2-blue)](https://go.dev/doc/devel/release#go1.23.0)

</div>


## ‚ú® Features

- Healthcheck
- Create student
- Read student
- Update student
- Delete student
- Search student

## ‚öôÔ∏è Main technologies

- Go
- Echo Web Framework
- Open Telemetry
- Otel Collector + Zipkin
- Zap Logger
- FX Dependency Injection System
- Go's database package + Postgres
- golang-migrate
- Docker
- Docker Compose
- Go's testing package
- Testcontainers (integration tests)
- Httpexpect  (end-to-end tests)

## ü§ì Main code patterns

This project also incorporates the following key design and code patterns to ensure robustness and maintainability:

- **Graceful Shutdown:** Ensures the application handles termination signals properly, cleaning up resources like connections, goroutines and processes.  
- **Decorator:** Adds behavior to existing structures or functions dynamically without modifying their source code.  
- **Builder:** Provides a clear and fluent way to construct complex objects step by step.  
- **Repository:** Abstracts data access logic, separating it from business logic and enabling easier testing and extensibility.

## üè¢ Architecture

This project follows the principles of **Clean Architecture**, promoting a clear separation of responsibilities and ensuring modular, testable and easy-to-maintain code. The layers used are:

- **Domain:**  
  Contains the core and independent elements of the system, including:  
  - **Entities:** Fundamental business rules.  
  - **Use Case Interfaces:** Define contracts that use cases must implement.  
  - **Repositories:** Interfaces for data persistence, abstracting implementation details.  
  - **DTOs:** Data Transfer Objects for clear communication between layers.  
  - **Mocks:** Simulated implementations to facilitate isolated testing and development.  

- **Adapters:**  
  Responsible for communication between the domain and the external world, such as inputs and outputs:  
  - **Handlers:** Entry layer exposing endpoints and translating requests into calls to use cases.  
  - **Repositories:** Concrete implementations of the repositories defined in the domain, connecting to the database.  

- **Infrastructure:**  
  Deals with technical details such as configurations, external integrations, and database connectivity.  

- **Use Cases:**  
  Contains the application logic, orchestrating operations between entities, repositories, and other layers.  

This organization ensures the independence of the domain from frameworks and technical details, providing greater flexibility and ease of maintenance.

## üöÄ How to run the project in local mode

```
1. Clone the project repository:
$ git clone https://github.com/dmarins/student-api.git

2. Access the project folder on your terminal:
$ cd student-api

3. Install dependencies:
$ go mod tidy

4. Run tests (make sure you are running docker on your machine):
$ make tests

6. Run the application in local mode (make sure you are running docker on your machine):
$ make local-restart
$ make run

7. Go to http://localhost:8080/swagger/index.html in your browser or see all http files in /.requests directory and tests all endpoints.

8. To stop all containers
$ make down
```

## üì¶ How to run the project in container mode

```
1. Clone the project repository:
$ git clone https://github.com/dmarins/student-api.git

2. Access the project folder on your terminal:
$ cd student-api

3. Install dependencies:
$ go mod tidy

4. Run tests (make sure you are running docker on your machine):
$ make tests

6. Run the application in container mode (make sure you are running docker on your machine):
$ make docker-restart

7. Go to http://localhost:8080/swagger/index.html in your browser or see all http files in /.requests directory and tests all endpoints.

8. To stop all containers
$ make down
```

================================================================================
File: cmd/main.go
Size: 705 B
================================================================================

package main

import (
	"github.com/dmarins/student-api/internal/infrastructure/di"
	"github.com/dmarins/student-api/internal/infrastructure/env"

	_ "github.com/dmarins/student-api/docs/openapi"
)

//	@title			Student Swagger Example API
//	@version		1.0
//	@description	This is an example API written in Go.
///	@termsOfService	http://swagger.io/terms/

///	@contact.name	API Support
///	@contact.url	http://www.swagger.io/support
///	@contact.email	support@swagger.io

///	@license.name	Apache 2.0
///	@license.url	http://www.apache.org/licenses/LICENSE-2.0.html

// @host		localhost:8080
// @BasePath	/
// @schemes	http
func main() {
	env.LoadEnvironmentVariables()
	di.StartCompositionRoot().Run()
}


================================================================================
File: docker-compose.local.yaml
Size: 1.12 kB
================================================================================

services:
  db:
    container_name: db
    image: postgres:16.4-alpine3.20
    env_file:
      - './.env.local'
    ports:
      - '5432:5432'
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: always

  migrator:
    container_name: migrator
    image: migrate/migrate:latest
    env_file:
      - './.env.local'
    command: ["-path=/migrations", "-database=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable", "up"]
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./migrations:/migrations

  otel-collector:
    container_name: otel-collector
    image: otel/opentelemetry-collector:latest
    command: ["--config=/etc/otel-collector-config.yaml"]
    ports:
      - "4317:4317"
      - "55681:55681"
      - "8888:8888"
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml

  zipkin:
    container_name: zipkin
    image: openzipkin/zipkin:latest
    ports:
      - "9411:9411"
    depends_on:
      - otel-collector

================================================================================
File: docker-compose.yaml
Size: 1.35 kB
================================================================================

services:
  db:
    container_name: db
    image: postgres:16.4-alpine3.20
    env_file:
      - './.env'
    ports:
      - '5432:5432'
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: always

  migrator:
    container_name: migrator
    image: migrate/migrate:latest
    env_file:
      - './.env'
    command: ["-path=/migrations", "-database=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable", "up"]
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./migrations:/migrations

  otel-collector:
    container_name: otel-collector
    image: otel/opentelemetry-collector:latest
    command: ["--config=/etc/otel-collector-config.yaml"]
    ports:
      - "4317:4317"
      - "55681:55681"
      - "8888:8888"
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml

  zipkin:
    container_name: zipkin
    image: openzipkin/zipkin:latest
    ports:
      - "9411:9411"
    depends_on:
      - otel-collector

  api:
    container_name: api
    image: students-api:latest
    build:
      context: .
      dockerfile: Dockerfile
    env_file:
      - './.env'
    ports:
      - "8080:8080"
    depends_on:
      db:
        condition: service_healthy

================================================================================
File: docs/openapi/docs.go
Size: 15.03 kB
================================================================================

// Package openapi Code generated by swaggo/swag. DO NOT EDIT
package openapi

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/health": {
            "get": {
                "description": "Checks if the API has connectivity to your database.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "healthcheck"
                ],
                "summary": "Check if the API is available.",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            }
        },
        "/v1/students": {
            "get": {
                "description": "Allows you to search for students by controlling pagination, sorting and filtering results.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to search the students.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "integer",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "name": "pageSize",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortField",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortOrder",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "name",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            },
            "post": {
                "description": "Allows you to create a student after validating duplicate names.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to create a student.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "description": "To create a student",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.StudentCreateInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            }
        },
        "/v1/students/{id}": {
            "get": {
                "description": "Allows you to get the details of a student by ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to get the details of a student.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "Student identifier",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            },
            "put": {
                "description": "Allows you to update a student's data after finding them and validating if there are duplicate names.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to update a student data.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "Student identifier",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "To update a student",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.StudentUpdateInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            },
            "delete": {
                "description": "Allows you to delete a student's data after finding them.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to delete a student data.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "Student identifier",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dtos.Result": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                }
            }
        },
        "dtos.StudentCreateInput": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 200
                }
            }
        },
        "dtos.StudentUpdateInput": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 200
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/",
	Schemes:          []string{"http"},
	Title:            "Student Swagger Example API",
	Description:      "This is an example API written in Go.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}


================================================================================
File: docs/openapi/swagger.json
Size: 14.39 kB
================================================================================

{
    "schemes": [
        "http"
    ],
    "swagger": "2.0",
    "info": {
        "description": "This is an example API written in Go.",
        "title": "Student Swagger Example API",
        "contact": {},
        "version": "1.0"
    },
    "host": "localhost:8080",
    "basePath": "/",
    "paths": {
        "/health": {
            "get": {
                "description": "Checks if the API has connectivity to your database.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "healthcheck"
                ],
                "summary": "Check if the API is available.",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            }
        },
        "/v1/students": {
            "get": {
                "description": "Allows you to search for students by controlling pagination, sorting and filtering results.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to search the students.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "integer",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "name": "pageSize",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortField",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortOrder",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "name",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            },
            "post": {
                "description": "Allows you to create a student after validating duplicate names.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to create a student.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "description": "To create a student",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.StudentCreateInput"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            }
        },
        "/v1/students/{id}": {
            "get": {
                "description": "Allows you to get the details of a student by ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to get the details of a student.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "Student identifier",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            },
            "put": {
                "description": "Allows you to update a student's data after finding them and validating if there are duplicate names.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to update a student data.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "Student identifier",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "To update a student",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dtos.StudentUpdateInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            },
            "delete": {
                "description": "Allows you to delete a student's data after finding them.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "students"
                ],
                "summary": "Allows you to delete a student data.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "To identify the tenant",
                        "name": "x-tenant",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "To identify the request",
                        "name": "x-cid",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "Student identifier",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/dtos.Result"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dtos.Result": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                }
            }
        },
        "dtos.StudentCreateInput": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 200
                }
            }
        },
        "dtos.StudentUpdateInput": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "maxLength": 200
                }
            }
        }
    }
}

================================================================================
File: docs/openapi/swagger.yaml
Size: 7.01 kB
================================================================================

basePath: /
definitions:
  dtos.Result:
    properties:
      data: {}
      message:
        type: string
    type: object
  dtos.StudentCreateInput:
    properties:
      name:
        maxLength: 200
        type: string
    required:
    - name
    type: object
  dtos.StudentUpdateInput:
    properties:
      name:
        maxLength: 200
        type: string
    required:
    - name
    type: object
host: localhost:8080
info:
  contact: {}
  description: This is an example API written in Go.
  title: Student Swagger Example API
  version: "1.0"
paths:
  /health:
    get:
      description: Checks if the API has connectivity to your database.
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/dtos.Result'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/dtos.Result'
      summary: Check if the API is available.
      tags:
      - healthcheck
  /v1/students:
    get:
      consumes:
      - application/json
      description: Allows you to search for students by controlling pagination, sorting
        and filtering results.
      parameters:
      - description: To identify the tenant
        in: header
        name: x-tenant
        required: true
        type: string
      - description: To identify the request
        in: header
        name: x-cid
        type: string
      - in: query
        name: page
        type: integer
      - in: query
        name: pageSize
        type: integer
      - in: query
        name: sortField
        type: string
      - in: query
        name: sortOrder
        type: string
      - in: query
        name: name
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/dtos.Result'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/dtos.Result'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/dtos.Result'
      summary: Allows you to search the students.
      tags:
      - students
    post:
      consumes:
      - application/json
      description: Allows you to create a student after validating duplicate names.
      parameters:
      - description: To identify the tenant
        in: header
        name: x-tenant
        required: true
        type: string
      - description: To identify the request
        in: header
        name: x-cid
        type: string
      - description: To create a student
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/dtos.StudentCreateInput'
      produces:
      - application/json
      responses:
        "201":
          description: Created
          schema:
            $ref: '#/definitions/dtos.Result'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/dtos.Result'
        "409":
          description: Conflict
          schema:
            $ref: '#/definitions/dtos.Result'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/dtos.Result'
      summary: Allows you to create a student.
      tags:
      - students
  /v1/students/{id}:
    delete:
      consumes:
      - application/json
      description: Allows you to delete a student's data after finding them.
      parameters:
      - description: To identify the tenant
        in: header
        name: x-tenant
        required: true
        type: string
      - description: To identify the request
        in: header
        name: x-cid
        type: string
      - description: Student identifier
        in: path
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: No Content
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/dtos.Result'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/dtos.Result'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/dtos.Result'
      summary: Allows you to delete a student data.
      tags:
      - students
    get:
      consumes:
      - application/json
      description: Allows you to get the details of a student by ID.
      parameters:
      - description: To identify the tenant
        in: header
        name: x-tenant
        required: true
        type: string
      - description: To identify the request
        in: header
        name: x-cid
        type: string
      - description: Student identifier
        in: path
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/dtos.Result'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/dtos.Result'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/dtos.Result'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/dtos.Result'
      summary: Allows you to get the details of a student.
      tags:
      - students
    put:
      consumes:
      - application/json
      description: Allows you to update a student's data after finding them and validating
        if there are duplicate names.
      parameters:
      - description: To identify the tenant
        in: header
        name: x-tenant
        required: true
        type: string
      - description: To identify the request
        in: header
        name: x-cid
        type: string
      - description: Student identifier
        in: path
        name: id
        required: true
        type: string
      - description: To update a student
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/dtos.StudentUpdateInput'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/dtos.Result'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/dtos.Result'
        "404":
          description: Not Found
          schema:
            $ref: '#/definitions/dtos.Result'
        "409":
          description: Conflict
          schema:
            $ref: '#/definitions/dtos.Result'
        "500":
          description: Internal Server Error
          schema:
            $ref: '#/definitions/dtos.Result'
      summary: Allows you to update a student data.
      tags:
      - students
schemes:
- http
swagger: "2.0"


================================================================================
File: go.mod
Size: 6.15 kB
================================================================================

module github.com/dmarins/student-api

go 1.23.2

require (
	github.com/gavv/httpexpect/v2 v2.16.0
	github.com/go-playground/validator/v10 v10.22.1
	github.com/google/uuid v1.6.0
	github.com/joho/godotenv v1.5.1
	github.com/labstack/echo/v4 v4.12.0
	github.com/lib/pq v1.10.9
	github.com/stretchr/testify v1.9.0
	github.com/swaggo/echo-swagger v1.4.1
	github.com/swaggo/swag v1.16.4
	github.com/testcontainers/testcontainers-go v0.33.0
	github.com/testcontainers/testcontainers-go/modules/postgres v0.33.0
	go.opentelemetry.io/otel v1.30.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.30.0
	go.opentelemetry.io/otel/sdk v1.30.0
	go.opentelemetry.io/otel/trace v1.30.0
	go.uber.org/fx v1.22.2
	go.uber.org/mock v0.4.0
	go.uber.org/zap v1.27.0
)

require (
	dario.cat/mergo v1.0.0 // indirect
	github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/PuerkitoBio/purell v1.1.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/TylerBrock/colorjson v0.0.0-20200706003622-8a50f05110d2 // indirect
	github.com/ajg/form v1.5.1 // indirect
	github.com/andybalholm/brotli v1.0.4 // indirect
	github.com/cenkalti/backoff/v4 v4.3.0 // indirect
	github.com/containerd/containerd v1.7.18 // indirect
	github.com/containerd/log v0.1.0 // indirect
	github.com/containerd/platforms v0.2.1 // indirect
	github.com/cpuguy83/dockercfg v0.3.1 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/distribution/reference v0.6.0 // indirect
	github.com/docker/docker v27.1.1+incompatible // indirect
	github.com/docker/go-connections v0.5.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/fatih/color v1.15.0 // indirect
	github.com/fatih/structs v1.1.0 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/gabriel-vasile/mimetype v1.4.5 // indirect
	github.com/ghodss/yaml v1.0.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.19.6 // indirect
	github.com/go-openapi/spec v0.20.4 // indirect
	github.com/go-openapi/swag v0.19.15 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/gobwas/glob v0.2.3 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/google/go-querystring v1.1.0 // indirect
	github.com/gorilla/websocket v1.4.2 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0 // indirect
	github.com/hpcloud/tail v1.0.0 // indirect
	github.com/imkira/go-interpol v1.1.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/klauspost/compress v1.17.4 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/go-wordwrap v1.0.1 // indirect
	github.com/moby/docker-image-spec v1.3.1 // indirect
	github.com/moby/patternmatcher v0.6.0 // indirect
	github.com/moby/sys/sequential v0.5.0 // indirect
	github.com/moby/sys/user v0.1.0 // indirect
	github.com/moby/term v0.5.0 // indirect
	github.com/morikuni/aec v1.0.0 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.1.0 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
	github.com/sanity-io/litter v1.5.5 // indirect
	github.com/sergi/go-diff v1.0.0 // indirect
	github.com/shirou/gopsutil/v3 v3.23.12 // indirect
	github.com/shoenig/go-m1cpu v0.1.6 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/swaggo/files/v2 v2.0.0 // indirect
	github.com/tklauser/go-sysconf v0.3.12 // indirect
	github.com/tklauser/numcpus v0.6.1 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasthttp v1.34.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	github.com/xeipuuv/gojsonschema v1.2.0 // indirect
	github.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0 // indirect
	github.com/yudai/gojsondiff v1.0.0 // indirect
	github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 // indirect
	github.com/yusufpapurcu/wmi v1.2.3 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.30.0 // indirect
	go.opentelemetry.io/otel/metric v1.30.0 // indirect
	go.opentelemetry.io/proto/otlp v1.3.1 // indirect
	go.uber.org/dig v1.18.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	golang.org/x/crypto v0.27.0 // indirect
	golang.org/x/net v0.29.0 // indirect
	golang.org/x/sys v0.25.0 // indirect
	golang.org/x/text v0.18.0 // indirect
	golang.org/x/time v0.6.0 // indirect
	golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240930140551-af27646dc61f // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240930140551-af27646dc61f // indirect
	google.golang.org/grpc v1.67.1 // indirect
	google.golang.org/protobuf v1.34.2 // indirect
	gopkg.in/fsnotify.v1 v1.4.7 // indirect
	gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	moul.io/http2curl/v2 v2.3.0 // indirect
)


================================================================================
File: go.sum
Size: 35.39 kB
================================================================================

dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
github.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24 h1:bvDV9vkmnHYOMsOr4WLk+Vo07yKIzd94sVoIqshQ4bU=
github.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24/go.mod h1:8o94RPi1/7XTJvwPpRSzSUedZrtlirdB3r9Z20bi2f8=
github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=
github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=
github.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/PuerkitoBio/purell v1.1.1 h1:WEQqlqaGbrPkxLJWfBwQmfEAE1Z7ONdDLqrN38tNFfI=
github.com/PuerkitoBio/purell v1.1.1/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=
github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=
github.com/TylerBrock/colorjson v0.0.0-20200706003622-8a50f05110d2 h1:ZBbLwSJqkHBuFDA6DUhhse0IGJ7T5bemHyNILUjvOq4=
github.com/TylerBrock/colorjson v0.0.0-20200706003622-8a50f05110d2/go.mod h1:VSw57q4QFiWDbRnjdX8Cb3Ow0SFncRw+bA/ofY6Q83w=
github.com/ajg/form v1.5.1 h1:t9c7v8JUKu/XxOGBU0yjNpaMloxGEJhUkqFRq0ibGeU=
github.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=
github.com/andybalholm/brotli v1.0.4 h1:V7DdXeJtZscaqfNuAdSRuRFzuiKlHSC/Zh3zl9qY3JY=
github.com/andybalholm/brotli v1.0.4/go.mod h1:fO7iG3H7G2nSZ7m0zPUDn85XEX2GTukHGRSepvi9Eig=
github.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=
github.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
github.com/containerd/containerd v1.7.18 h1:jqjZTQNfXGoEaZdW1WwPU0RqSn1Bm2Ay/KJPUuO8nao=
github.com/containerd/containerd v1.7.18/go.mod h1:IYEk9/IO6wAPUz2bCMVUbsfXjzw5UNP5fLz4PsUygQ4=
github.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=
github.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=
github.com/containerd/platforms v0.2.1 h1:zvwtM3rz2YHPQsF2CHYM8+KtB5dvhISiXh5ZpSBQv6A=
github.com/containerd/platforms v0.2.1/go.mod h1:XHCb+2/hzowdiut9rkudds9bE5yJ7npe7dG/wG+uFPw=
github.com/cpuguy83/dockercfg v0.3.1 h1:/FpZ+JaygUR/lZP2NlFI2DVfrOEMAIKP5wWEJdoYe9E=
github.com/cpuguy83/dockercfg v0.3.1/go.mod h1:sugsbF4//dDlL/i+S+rtpIWp+5h0BHJHfjj5/jFyUJc=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/creack/pty v1.1.18 h1:n56/Zwd5o6whRC5PMGretI4IdRLlmBXYNjScPaBgsbY=
github.com/creack/pty v1.1.18/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=
github.com/davecgh/go-spew v0.0.0-20161028175848-04cdfd42973b/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/docker/docker v27.1.1+incompatible h1:hO/M4MtV36kzKldqnA37IWhebRA+LnqqcqDja6kVaKY=
github.com/docker/docker v27.1.1+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/fatih/color v1.15.0 h1:kOqh6YHBtK8aywxGerMG2Eq3H6Qgoqeo13Bk2Mv/nBs=
github.com/fatih/color v1.15.0/go.mod h1:0h5ZqXfHYED7Bhv2ZJamyIOUej9KtShiJESRwBDUSsw=
github.com/fatih/structs v1.1.0 h1:Q7juDM0QtcnhCpeyLGQKyg4TOIghuNXrkL32pHAUMxo=
github.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/gabriel-vasile/mimetype v1.4.5 h1:J7wGKdGu33ocBOhGy0z653k/lFKLFDPJMG8Gql0kxn4=
github.com/gabriel-vasile/mimetype v1.4.5/go.mod h1:ibHel+/kbxn9x2407k1izTA1S81ku1z/DlgOW2QE0M4=
github.com/gavv/httpexpect/v2 v2.16.0 h1:Ty2favARiTYTOkCRZGX7ojXXjGyNAIohM1lZ3vqaEwI=
github.com/gavv/httpexpect/v2 v2.16.0/go.mod h1:uJLaO+hQ25ukBJtQi750PsztObHybNllN+t+MbbW8PY=
github.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-ole/go-ole v1.2.6 h1:/Fpf6oFPoeFik9ty7siob0G6Ke8QvQEuVcuChpwXzpY=
github.com/go-ole/go-ole v1.2.6/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-openapi/jsonpointer v0.19.3/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=
github.com/go-openapi/jsonpointer v0.19.5 h1:gZr+CIYByUqjcgeLXnQu2gHYQC9o73G2XUeOFYEICuY=
github.com/go-openapi/jsonpointer v0.19.5/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=
github.com/go-openapi/jsonreference v0.19.6 h1:UBIxjkht+AWIgYzCDSv2GN+E/togfwXUJFRTWhl2Jjs=
github.com/go-openapi/jsonreference v0.19.6/go.mod h1:diGHMEHg2IqXZGKxqyvWdfWU/aim5Dprw5bqpKkTvns=
github.com/go-openapi/spec v0.20.4 h1:O8hJrt0UMnhHcluhIdUgCLRWyM2x7QkBXRvOs7m+O1M=
github.com/go-openapi/spec v0.20.4/go.mod h1:faYFR1CvsJZ0mNsmsphTMSoRrNV3TEDoAM7FOEWeq8I=
github.com/go-openapi/swag v0.19.5/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=
github.com/go-openapi/swag v0.19.15 h1:D2NRCBzS9/pEY3gP9Nl8aDqGUcPFrwG2p+CNFrLyrCM=
github.com/go-openapi/swag v0.19.15/go.mod h1:QYRuS/SOXUCsnplDa677K7+DxSOj6IPNl/eQntq43wQ=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.22.1 h1:40JcKH+bBNGFczGuoBYgX4I6m/i27HYW8P9FDk5PbgA=
github.com/go-playground/validator/v10 v10.22.1/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/gobwas/glob v0.2.3 h1:A4xDbljILXROh+kObIiy5kIaPYD8e96x1tgBhUI5J+Y=
github.com/gobwas/glob v0.2.3/go.mod h1:d3Ez4x06l9bZtSvzIay5+Yzi0fmZzPgnTbPcKjJAkT8=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-jwt/jwt v3.2.2+incompatible h1:IfV12K8xAKAnZqdXVzCZ+TOjboZ2keLg81eXfW3O+oY=
github.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=
github.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=
github.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=
github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0 h1:asbCHRVmodnJTuQ3qamDwqVOIjwqUPTYmYuemVOx+Ys=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0/go.mod h1:ggCgvZ2r7uOoQjOyu2Y1NhHmEPPzzuhWgcza5M1Ji1I=
github.com/hokaccha/go-prettyjson v0.0.0-20211117102719-0474bc63780f h1:7LYC+Yfkj3CTRcShK0KOL/w6iTiKyqqBA9a41Wnggw8=
github.com/hokaccha/go-prettyjson v0.0.0-20211117102719-0474bc63780f/go.mod h1:pFlLw2CfqZiIBOx6BuCeRLCrfxBJipTY0nIOF/VbGcI=
github.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=
github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
github.com/imkira/go-interpol v1.1.0 h1:KIiKr0VSG2CUW1hl1jpiyuzuJeKUUpC8iM1AIE7N1Vk=
github.com/imkira/go-interpol v1.1.0/go.mod h1:z0h2/2T3XF8kyEPpRgJ3kmNv+C43p+I/CoI+jC3w2iA=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=
github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.5.4 h1:Xp2aQS8uXButQdnCMWNmvx6UysWQQC+u1EoizjguY+8=
github.com/jackc/pgx/v5 v5.5.4/go.mod h1:ez9gk+OAat140fv9ErkZDYFWmXLfV+++K0uAOiwgm1A=
github.com/jackc/puddle/v2 v2.2.1 h1:RhxXJtFG022u4ibrCSMSiu5aOq1i77R3OHKNJj77OAk=
github.com/jackc/puddle/v2 v2.2.1/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/klauspost/compress v1.15.0/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
github.com/klauspost/compress v1.17.4 h1:Ej5ixsIri7BrIjBkRZLTo6ghwrEtHFk7ijlczPW4fZ4=
github.com/klauspost/compress v1.17.4/go.mod h1:/dCuZOvVtNoHsyb+cuJD3itjs3NbnF6KH9zAO4BDxPM=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/labstack/echo/v4 v4.12.0 h1:IKpw49IMryVB2p1a4dzwlhP1O2Tf2E0Ir/450lH+kI0=
github.com/labstack/echo/v4 v4.12.0/go.mod h1:UP9Cr2DJXbOK3Kr9ONYzNowSh7HP0aG0ShAyycHSJvM=
github.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=
github.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 h1:6E+4a0GO5zZEnZ81pIr0yLvtUWk2if982qA3F3QD6H4=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0/go.mod h1:zJYVVT2jmtg6P3p1VtQj7WsuWi/y4VnjVBn7F8KPB3I=
github.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=
github.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=
github.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
github.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
github.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mitchellh/go-wordwrap v1.0.1 h1:TLuKupo69TCn6TQSyGxwI1EblZZEsQ0vMlAFQflz0v0=
github.com/mitchellh/go-wordwrap v1.0.1/go.mod h1:R62XHJLzvMFRBbcrT7m7WgmE1eOyTSsCt+hzestvNj0=
github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/patternmatcher v0.6.0 h1:GmP9lR19aU5GqSSFko+5pRqHi+Ohk1O69aFiKkVGiPk=
github.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=
github.com/moby/sys/sequential v0.5.0 h1:OPvI35Lzn9K04PBbCLW0g4LcFAJgHsvXsRyewg5lXtc=
github.com/moby/sys/sequential v0.5.0/go.mod h1:tH2cOOs5V9MlPiXcQzRC+eEyab644PWKGRYaaV5ZZlo=
github.com/moby/sys/user v0.1.0 h1:WmZ93f5Ux6het5iituh9x2zAG7NFY9Aqi49jjE1PaQg=
github.com/moby/sys/user v0.1.0/go.mod h1:fKJhFOnsCN6xZ5gSfbM6zaHGgDJMrqt9/reuj4T7MmU=
github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=
github.com/onsi/ginkgo v1.10.1 h1:q/mM8GF/n0shIN8SaAZ0V+jnLPzen6WIVZdiwrRlMlo=
github.com/onsi/ginkgo v1.10.1/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/gomega v1.7.0 h1:XPnZz8VVBHjVsy1vzJmRwIcSwiUO+JFfrv/xGiigmME=
github.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
github.com/pkg/diff v0.0.0-20200914180035-5b29258ca4f7/go.mod h1:zO8QMzTeZd5cpnIkz/Gn6iK0jDfGicM1nynOkkPIl28=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v0.0.0-20151028094244-d8ed2627bdf0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c h1:ncq/mPwQF4JjgDlrVEn3C11VoGHZN7m8qihwgMEtzYw=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=
github.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=
github.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=
github.com/sanity-io/litter v1.5.5 h1:iE+sBxPBzoK6uaEP5Lt3fHNgpKcHXc/A2HGETy0uJQo=
github.com/sanity-io/litter v1.5.5/go.mod h1:9gzJgR2i4ZpjZHsKvUXIRQVk7P+yM3e+jAF7bU2UI5U=
github.com/sergi/go-diff v1.0.0 h1:Kpca3qRNrduNnOQeazBd0ysaKrUJiIuISHxogkT9RPQ=
github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=
github.com/shirou/gopsutil/v3 v3.23.12 h1:z90NtUkp3bMtmICZKpC4+WaknU1eXtp5vtbQ11DgpE4=
github.com/shirou/gopsutil/v3 v3.23.12/go.mod h1:1FrWgea594Jp7qmjHUUPlJDTPgcsb9mGnXDxavtikzM=
github.com/shoenig/go-m1cpu v0.1.6 h1:nxdKQNcEB6vzgA2E2bvzKIYRuNj7XNJ4S/aRSwKzFtM=
github.com/shoenig/go-m1cpu v0.1.6/go.mod h1:1JJMcUBvfNwpq05QDQVAnx3gUHr9IYF7GNg9SUEw2VQ=
github.com/shoenig/test v0.6.4 h1:kVTaSd7WLz5WZ2IaoM0RSzRsUD+m8wRR+5qvntpn4LU=
github.com/shoenig/test v0.6.4/go.mod h1:byHiCGXqrVaflBLAMq/srcZIHynQPQgeyvkvXnjqq0k=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v0.0.0-20161117074351-18a02ba4a312/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/swaggo/echo-swagger v1.4.1 h1:Yf0uPaJWp1uRtDloZALyLnvdBeoEL5Kc7DtnjzO/TUk=
github.com/swaggo/echo-swagger v1.4.1/go.mod h1:C8bSi+9yH2FLZsnhqMZLIZddpUxZdBYuNHbtaS1Hljc=
github.com/swaggo/files/v2 v2.0.0 h1:hmAt8Dkynw7Ssz46F6pn8ok6YmGZqHSVLZ+HQM7i0kw=
github.com/swaggo/files/v2 v2.0.0/go.mod h1:24kk2Y9NYEJ5lHuCra6iVwkMjIekMCaFq/0JQj66kyM=
github.com/swaggo/swag v1.16.4 h1:clWJtd9LStiG3VeijiCfOVODP6VpHtKdQy9ELFG3s1A=
github.com/swaggo/swag v1.16.4/go.mod h1:VBsHJRsDvfYvqoiMKnsdwhNV9LEMHgEDZcyVYX0sxPg=
github.com/tailscale/depaware v0.0.0-20210622194025-720c4b409502/go.mod h1:p9lPsd+cx33L3H9nNoecRRxPssFKUwwI50I3pZ0yT+8=
github.com/testcontainers/testcontainers-go v0.33.0 h1:zJS9PfXYT5O0ZFXM2xxXfk4J5UMw/kRiISng037Gxdw=
github.com/testcontainers/testcontainers-go v0.33.0/go.mod h1:W80YpTa8D5C3Yy16icheD01UTDu+LmXIA2Keo+jWtT8=
github.com/testcontainers/testcontainers-go/modules/postgres v0.33.0 h1:c+Gt+XLJjqFAejgX4hSpnHIpC9eAhvgI/TFWL/PbrFI=
github.com/testcontainers/testcontainers-go/modules/postgres v0.33.0/go.mod h1:I4DazHBoWDyf69ByOIyt3OdNjefiUx372459txOpQ3o=
github.com/tklauser/go-sysconf v0.3.12 h1:0QaGUFOdQaIVdPgfITYzaTegZvdCjmYO52cSFAEVmqU=
github.com/tklauser/go-sysconf v0.3.12/go.mod h1:Ho14jnntGE1fpdOqQEEaiKRpvIavV0hSfmBq8nJbHYI=
github.com/tklauser/numcpus v0.6.1 h1:ng9scYS7az0Bk4OZLvrNXNSAO2Pxr1XXRAPyjhIx+Fk=
github.com/tklauser/numcpus v0.6.1/go.mod h1:1XfjsgE2zo8GVw7POkMbHENHzVg3GzmoZ9fESEdAacY=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasthttp v1.34.0 h1:d3AAQJ2DRcxJYHm7OXNXtXt2as1vMDfxeIcFvhmGGm4=
github.com/valyala/fasthttp v1.34.0/go.mod h1:epZA5N+7pY6ZaEKRmstzOuYJx9HI8DI1oaCGZpdH4h0=
github.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=
github.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb h1:zGWFAtiMcyryUHoUjUJX0/lt1H2+i2Ka2n+D3DImSNo=
github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=
github.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=
github.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=
github.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0 h1:6fRhSjgLCkTD3JnJxvaJ4Sj+TYblw757bqYgZaOq5ZY=
github.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0/go.mod h1:/LWChgwKmvncFJFHJ7Gvn9wZArjbV5/FppcK2fKk/tI=
github.com/yudai/gojsondiff v1.0.0 h1:27cbfqXLVEJ1o8I6v3y9lg8Ydm53EKqHXAOMxEGlCOA=
github.com/yudai/gojsondiff v1.0.0/go.mod h1:AY32+k2cwILAkW1fbgxQ5mUmMiZFgLIV+FBNExI05xg=
github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 h1:BHyfKlQyqbsFN5p3IfnEUduWvb9is428/nNb5L3U01M=
github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=
github.com/yudai/pp v2.0.1+incompatible h1:Q4//iY4pNF6yPLZIigmvcl7k/bPgrcTPIFIcmawg5bI=
github.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yusufpapurcu/wmi v1.2.3 h1:E1ctvB7uKFMOJw3fdOW32DwGE9I7t++CRUEMKvFoFiw=
github.com/yusufpapurcu/wmi v1.2.3/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 h1:jq9TW8u3so/bN+JPT166wjOI6/vQPF6Xe7nMNIltagk=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=
go.opentelemetry.io/otel v1.30.0 h1:F2t8sK4qf1fAmY9ua4ohFS/K+FUuOPemHUIXHtktrts=
go.opentelemetry.io/otel v1.30.0/go.mod h1:tFw4Br9b7fOS+uEao81PJjVMjW/5fvNCbpsDIXqP0pc=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.30.0 h1:lsInsfvhVIfOI6qHVyysXMNDnjO9Npvl7tlDPJFBVd4=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.30.0/go.mod h1:KQsVNh4OjgjTG0G6EiNi1jVpnaeeKsKMRwbLN+f1+8M=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.30.0 h1:m0yTiGDLUvVYaTFbAvCkVYIYcvwKt3G7OLoN77NUs/8=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.30.0/go.mod h1:wBQbT4UekBfegL2nx0Xk1vBcnzyBPsIVm9hRG4fYcr4=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0 h1:IeMeyr1aBvBiPVYihXIaeIZba6b8E1bYp7lbdxK8CQg=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0/go.mod h1:oVdCUtjq9MK9BlS7TtucsQwUcXcymNiEDjgDD2jMtZU=
go.opentelemetry.io/otel/metric v1.30.0 h1:4xNulvn9gjzo4hjg+wzIKG7iNFEaBMX00Qd4QIZs7+w=
go.opentelemetry.io/otel/metric v1.30.0/go.mod h1:aXTfST94tswhWEb+5QjlSqG+cZlmyXy/u8jFpor3WqQ=
go.opentelemetry.io/otel/sdk v1.30.0 h1:cHdik6irO49R5IysVhdn8oaiR9m8XluDaJAs4DfOrYE=
go.opentelemetry.io/otel/sdk v1.30.0/go.mod h1:p14X4Ok8S+sygzblytT1nqG98QG2KYKv++HE0LY/mhg=
go.opentelemetry.io/otel/trace v1.30.0 h1:7UBkkYzeg3C7kQX8VAidWh2biiQbtAKjyIML8dQ9wmc=
go.opentelemetry.io/otel/trace v1.30.0/go.mod h1:5EyKqTzzmyqB9bwtCCq6pDLktPK6fmGf/Dph+8VI02o=
go.opentelemetry.io/proto/otlp v1.3.1 h1:TrMUixzpM0yuc/znrFTP9MMRh8trP93mkCiDVeXrui0=
go.opentelemetry.io/proto/otlp v1.3.1/go.mod h1:0X1WI4de4ZsLrrJNLAQbFeLCm3T7yBkR0XqQ7niQU+8=
go.uber.org/dig v1.18.0 h1:imUL1UiY0Mg4bqbFfsRQO5G4CGRBec/ZujWTvSVp3pw=
go.uber.org/dig v1.18.0/go.mod h1:Us0rSJiThwCv2GteUN0Q7OKvU7n5J4dxZ9JKUXozFdE=
go.uber.org/fx v1.22.2 h1:iPW+OPxv0G8w75OemJ1RAnTUrF55zOJlXlo1TbJ0Buw=
go.uber.org/fx v1.22.2/go.mod h1:o/D9n+2mLP6v1EG+qsdT1O8wKopYAsqZasju97SDFCU=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/mock v0.4.0 h1:VcM4ZOtdbR4f6VXfiOpwpVJDL6lCReaZ6mw31wqh7KU=
go.uber.org/mock v0.4.0/go.mod h1:a6FSlNadKUHUa9IP5Vyt1zh4fC7uAwxMutEAscFbkZc=
go.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=
go.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20220214200702-86341886e292/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/crypto v0.27.0 h1:GXm2NjJrPaiv/h1tb2UH8QfgC/hOf/+z0p6PT8o1w7A=
golang.org/x/crypto v0.27.0/go.mod h1:1Xngt8kV6Dvbssa53Ziq6Eqn0HqbZi5Z6R0ZpwQzt70=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210421230115-4e50805a0758/go.mod h1:72T/g9IO56b78aLF+1Kcs5dz7/ng1VjMUvfKvpfy+jM=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20220225172249-27dd8689420f/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/net v0.29.0 h1:5ORfpBpCs4HzDYoodCDBbwHzdR5UrLBZ3sOnUJmFoHo=
golang.org/x/net v0.29.0/go.mod h1:gLkgy8jTGERgjzMic6DS9+SP0ajcu6Xu3Orq/SpETg0=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=
golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201204225414-ed752295db88/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210420072515-93ed5bcd2bfe/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220227234510-4e6760a101f9/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.24.0 h1:Mh5cbb+Zk2hqqXNO7S1iTjEphVL+jb8ZWaqh/g+JWkM=
golang.org/x/term v0.24.0/go.mod h1:lOBK/LVxemqiMij05LGJ0tzNr8xlmwBRJ81PX6wVLH8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=
golang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
golang.org/x/time v0.6.0 h1:eTDhh4ZXt5Qf0augr54TN6suAUudPcawVZeIAPU7D4U=
golang.org/x/time v0.6.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20201211185031-d93e913c1a58/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/genproto/googleapis/api v0.0.0-20240930140551-af27646dc61f h1:jTm13A2itBi3La6yTGqn8bVSrc3ZZ1r8ENHlIXBfnRA=
google.golang.org/genproto/googleapis/api v0.0.0-20240930140551-af27646dc61f/go.mod h1:CLGoBuH1VHxAUXVPP8FfPwPEVJB6lz3URE5mY2SuayE=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240930140551-af27646dc61f h1:cUMEy+8oS78BWIH9OWazBkzbr090Od9tWBNtZHkOhf0=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240930140551-af27646dc61f/go.mod h1:UqMtugtsSgubUsoxbuAoiCXvqvErP7Gf0so0mK9tHxU=
google.golang.org/grpc v1.67.1 h1:zWnc1Vrcno+lHZCOofnIMvycFcc0QRGIzm9dhnDX68E=
google.golang.org/grpc v1.67.1/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=
google.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=
google.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/fsnotify.v1 v1.4.7 h1:xOHLXZwVvI9hhs+cLKq5+I5onOuwQLhQwiu63xxlHs4=
gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gotest.tools/v3 v3.5.1 h1:EENdUnS3pdur5nybKYIh2Vfgc8IUNBjxDPSjtiJcOzU=
gotest.tools/v3 v3.5.1/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=
moul.io/http2curl/v2 v2.3.0 h1:9r3JfDzWPcbIklMOs2TnIFzDYvfAZvjeavG6EzP7jYs=
moul.io/http2curl/v2 v2.3.0/go.mod h1:RW4hyBjTWSYDOxapodpNEtX0g5Eb16sxklBqmd2RHcE=


================================================================================
File: internal/adapters/handlers/handler_helper.go
Size: 748 B
================================================================================

package handlers

import (
	"net/http"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/labstack/echo/v4"
)

func ReturnResult(ectx echo.Context, result *dtos.Result) error {
	switch result.Code {
	case http.StatusOK:
		return ectx.JSON(http.StatusOK, result)
	case http.StatusCreated:
		return ectx.JSON(http.StatusCreated, result)
	case http.StatusNoContent:
		return echo.NewHTTPError(http.StatusNoContent, nil)
	case http.StatusNotFound:
		return echo.NewHTTPError(http.StatusNotFound, result.Message)
	case http.StatusConflict:
		return echo.NewHTTPError(http.StatusConflict, result.Message)
	case http.StatusInternalServerError:
		return echo.NewHTTPError(http.StatusInternalServerError, result.Message)
	}

	return nil
}


================================================================================
File: internal/adapters/handlers/healthcheck_handler.go
Size: 1.61 kB
================================================================================

package handlers

import (
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/server"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	echo "github.com/labstack/echo/v4"
)

type HealthCheckHandler struct {
	Tracer             tracer.ITracer
	Logger             logger.ILogger
	HealthCheckUseCase usecases.IHealthCheckUseCase
}

func NewHealthCheckHandler(tracer tracer.ITracer, logger logger.ILogger, healthCheckUseCase usecases.IHealthCheckUseCase) *HealthCheckHandler {
	handler := &HealthCheckHandler{
		Tracer:             tracer,
		Logger:             logger,
		HealthCheckUseCase: healthCheckUseCase,
	}

	return handler
}

func RegisterHealthCheckRoute(s server.IServer, h *HealthCheckHandler) {
	s.GetEcho().GET("/health", h.Get)
}

// HealthCheck godoc
//
//	@Summary		Check if the API is available.
//	@Description	Checks if the API has connectivity to your database.
//	@Tags			healthcheck
//	@Produce		json
//	@Success		200	{object}	dtos.Result
//	@Failure		500	{object}	dtos.Result
//	@Router			/health [get]
func (h *HealthCheckHandler) Get(ectx echo.Context) error {
	span, ctx := h.Tracer.NewRootSpan(ectx.Request(), tracer.HealthCheckHandlerGet)
	defer span.End()

	h.Tracer.AddAttributes(span, tracer.HealthCheckHandlerGet,
		tracer.Attributes{
			"Cid": ectx.Request().Header.Get(env.ProvideCidHeaderName()),
		})

	return ReturnResult(ectx, h.HealthCheckUseCase.Execute(ctx))
}


================================================================================
File: internal/adapters/handlers/healthcheck_handler_test.go
Size: 640 B
================================================================================

package handlers_test

import (
	"net/http"
	"testing"
)

func TestHealthCheckHandler_Get_WithWrongMethod(t *testing.T) {
	e := builder.Build(t)

	e.PATCH("/health").
		Expect().
		Status(http.StatusMethodNotAllowed)
}

func TestHealthCheckHandler_Get_WithWrongPath(t *testing.T) {
	e := builder.Build(t)

	e.GET("/healthhhh").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound)
}

func TestHealthCheckHandler_Get_WhenReturnsHealthy(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/health").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual("healthy")
}


================================================================================
File: internal/adapters/handlers/main_test.go
Size: 1.89 kB
================================================================================

package handlers_test

import (
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
)

type fakeValues struct {
	fakeStudentCreateInput        *dtos.StudentCreateInput
	fakeStudentUpdateInput        *dtos.StudentUpdateInput
	fakeStudentCreateInputInvalid *dtos.StudentCreateInput
	fakeStudentUpdateInputInvalid *dtos.StudentUpdateInput
	fakeStudentCreateInputStored  *dtos.StudentCreateInput
	fakeStudentUpdateInputStored  *dtos.StudentUpdateInput
	fakeStudent                   *entities.Student
	fakeStudentToBeDeleted        string
}

var f *fakeValues
var builder *tests.E2eTestsBuilder

// TestMain will run before all the tests in the package handlers_test
func TestMain(m *testing.M) {
	// Setup: Create the builder and initialize the container
	builder = tests.
		NewE2eTestsBuilder().
		StartCompositionRoot().
		StartTestServer()

	f = &fakeValues{
		fakeStudentCreateInput: &dtos.StudentCreateInput{
			Name: "john doe",
		},
		fakeStudentCreateInputInvalid: &dtos.StudentCreateInput{
			Name: "",
		},
		fakeStudentCreateInputStored: &dtos.StudentCreateInput{
			Name: "alice",
		},
		fakeStudent: &entities.Student{
			ID:   "06b2ec25-3fe0-475e-9077-e77a113f4727",
			Name: "alice",
		},
		fakeStudentUpdateInput: &dtos.StudentUpdateInput{
			Name: "ashley updated",
		},
		fakeStudentUpdateInputInvalid: &dtos.StudentUpdateInput{
			Name: "",
		},
		fakeStudentUpdateInputStored: &dtos.StudentUpdateInput{
			Name: "alice",
		},
		fakeStudentToBeDeleted: "8e99273f-e566-4476-836e-048b1ecd9c4d",
	}

	// Run all tests in handlers_test
	code := m.Run()

	// Teardown: Stop all after all tests
	func() {
		builder.App.Stop(builder.Ctx)
		builder.TestServer.Close()
	}()

	// Exit with the code returned by the tests
	os.Exit(code)
}


================================================================================
File: internal/adapters/handlers/student_handler.go
Size: 10.14 kB
================================================================================

package handlers

import (
	"net/http"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/server"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/dmarins/student-api/internal/infrastructure/uuid"
	echo "github.com/labstack/echo/v4"
)

type StudentHandler struct {
	Tracer               tracer.ITracer
	Logger               logger.ILogger
	StudentCreateUseCase usecases.IStudentCreateUseCase
	StudentReadUseCase   usecases.IStudentReadUseCase
	StudentUpdateUseCase usecases.IStudentUpdateUseCase
	StudentDeleteUseCase usecases.IStudentDeleteUseCase
	StudentSearchUseCase usecases.IStudentSearchUseCase
}

func NewStudentHandler(
	tracer tracer.ITracer,
	logger logger.ILogger,
	studentCreateUseCase usecases.IStudentCreateUseCase,
	studentReadingUseCase usecases.IStudentReadUseCase,
	studentUpdateUseCase usecases.IStudentUpdateUseCase,
	studentDeleteUseCase usecases.IStudentDeleteUseCase,
	studentSearchUseCase usecases.IStudentSearchUseCase) *StudentHandler {
	handler := &StudentHandler{
		Tracer:               tracer,
		Logger:               logger,
		StudentCreateUseCase: studentCreateUseCase,
		StudentReadUseCase:   studentReadingUseCase,
		StudentUpdateUseCase: studentUpdateUseCase,
		StudentDeleteUseCase: studentDeleteUseCase,
		StudentSearchUseCase: studentSearchUseCase,
	}

	return handler
}

func RegisterStudentRoutes(s server.IServer, h *StudentHandler) {
	routesGroup := s.GetEcho().Group("/v1/students")

	routesGroup.POST("", h.Create)
	routesGroup.GET("/:id", h.Read)
	routesGroup.PUT("/:id", h.Update)
	routesGroup.DELETE("/:id", h.Delete)
	routesGroup.GET("", h.Search)
}

// StudentCreate godoc
//
//	@Summary		Allows you to create a student.
//	@Description	Allows you to create a student after validating duplicate names.
//	@Tags			students
//	@Param			x-tenant	header	string					true	"To identify the tenant"
//	@Param			x-cid		header	string					false	"To identify the request"
//	@Param			payload		body	dtos.StudentCreateInput	true	"To create a student"
//	@Accept			json
//	@Produce		json
//	@Success		201	{object}	dtos.Result
//	@Failure		400	{object}	dtos.Result
//	@Failure		409	{object}	dtos.Result
//	@Failure		500	{object}	dtos.Result
//	@Router			/v1/students [post]
func (h *StudentHandler) Create(ectx echo.Context) error {
	span, ctx := h.Tracer.NewRootSpan(ectx.Request(), tracer.StudentHandlerCreate)
	defer span.End()

	h.Tracer.AddAttributes(span, tracer.StudentHandlerCreate,
		tracer.Attributes{
			"Tenant": ectx.Request().Header.Get(env.ProvideTenantHeaderName()),
		})

	var studentCreateInput dtos.StudentCreateInput
	if err := ectx.Bind(&studentCreateInput); err != nil {
		h.Logger.Warn(ctx, "invalid payload, check the data sent", "error", err.Error())

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "echo bind ok")

	if err := ectx.Validate(&studentCreateInput); err != nil {
		h.Logger.Warn(ctx, "invalid field", "error", err.Error())

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "echo validate ok")

	return ReturnResult(ectx, h.StudentCreateUseCase.Execute(ctx, studentCreateInput))
}

// StudentRead godoc
//
//	@Summary		Allows you to get the details of a student.
//	@Description	Allows you to get the details of a student by ID.
//	@Tags			students
//	@Param			x-tenant	header	string	true	"To identify the tenant"
//	@Param			x-cid		header	string	false	"To identify the request"
//	@Param			id			path	string	true	"Student identifier"
//	@Accept			json
//	@Produce		json
//	@Success		200	{object}	dtos.Result
//	@Failure		400	{object}	dtos.Result
//	@Failure		404	{object}	dtos.Result
//	@Failure		500	{object}	dtos.Result
//	@Router			/v1/students/{id} [get]
func (h *StudentHandler) Read(ectx echo.Context) error {
	span, ctx := h.Tracer.NewRootSpan(ectx.Request(), tracer.StudentHandlerRead)
	defer span.End()

	studentId := ectx.Param("id")

	h.Tracer.AddAttributes(span, tracer.StudentHandlerRead,
		tracer.Attributes{
			"Tenant":    ectx.Request().Header.Get(env.ProvideTenantHeaderName()),
			"StudentId": studentId,
		})

	ok := uuid.IsValid(studentId)
	if !ok {
		h.Logger.Warn(ctx, "identifier format is invalid", "id", studentId)

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "identifier format ok")

	return ReturnResult(ectx, h.StudentReadUseCase.Execute(ctx, studentId))
}

// StudentUpdate godoc
//
//	@Summary		Allows you to update a student data.
//	@Description	Allows you to update a student's data after finding them and validating if there are duplicate names.
//	@Tags			students
//	@Param			x-tenant	header	string					true	"To identify the tenant"
//	@Param			x-cid		header	string					false	"To identify the request"
//	@Param			id			path	string					true	"Student identifier"
//	@Param			payload		body	dtos.StudentUpdateInput	true	"To update a student"
//	@Accept			json
//	@Produce		json
//	@Success		200	{object}	dtos.Result
//	@Failure		400	{object}	dtos.Result
//	@Failure		404	{object}	dtos.Result
//	@Failure		409	{object}	dtos.Result
//	@Failure		500	{object}	dtos.Result
//	@Router			/v1/students/{id} [put]
func (h *StudentHandler) Update(ectx echo.Context) error {
	span, ctx := h.Tracer.NewRootSpan(ectx.Request(), tracer.StudentHandlerUpdate)
	defer span.End()

	studentId := ectx.Param("id")

	h.Tracer.AddAttributes(span, tracer.StudentHandlerUpdate,
		tracer.Attributes{
			"Tenant":    ectx.Request().Header.Get(env.ProvideTenantHeaderName()),
			"StudentId": studentId,
		})

	ok := uuid.IsValid(studentId)
	if !ok {
		h.Logger.Warn(ctx, "identifier format is invalid", "id", studentId)

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "identifier format ok")

	var studentUpdateInput dtos.StudentUpdateInput
	if err := ectx.Bind(&studentUpdateInput); err != nil {
		h.Logger.Warn(ctx, "invalid payload, check the data sent", "error", err.Error())

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "echo bind ok")

	studentUpdateInput.ID = studentId
	if err := ectx.Validate(&studentUpdateInput); err != nil {
		h.Logger.Warn(ctx, "invalid field", "error", err.Error())

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "echo validate ok")

	return ReturnResult(ectx, h.StudentUpdateUseCase.Execute(ctx, studentUpdateInput))
}

// StudentDelete godoc
//
//	@Summary		Allows you to delete a student data.
//	@Description	Allows you to delete a student's data after finding them.
//	@Tags			students
//	@Param			x-tenant	header	string	true	"To identify the tenant"
//	@Param			x-cid		header	string	false	"To identify the request"
//	@Param			id			path	string	true	"Student identifier"
//	@Accept			json
//	@Produce		json
//	@Success		204
//	@Failure		400	{object}	dtos.Result
//	@Failure		404	{object}	dtos.Result
//	@Failure		500	{object}	dtos.Result
//	@Router			/v1/students/{id} [delete]
func (h *StudentHandler) Delete(ectx echo.Context) error {
	span, ctx := h.Tracer.NewRootSpan(ectx.Request(), tracer.StudentHandlerDelete)
	defer span.End()

	studentId := ectx.Param("id")

	h.Tracer.AddAttributes(span, tracer.StudentHandlerDelete,
		tracer.Attributes{
			"Tenant":    ectx.Request().Header.Get(env.ProvideTenantHeaderName()),
			"StudentId": studentId,
		})

	ok := uuid.IsValid(studentId)
	if !ok {
		h.Logger.Warn(ctx, "identifier format is invalid", "id", studentId)

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Logger.Debug(ctx, "identifier format ok")

	return ReturnResult(ectx, h.StudentDeleteUseCase.Execute(ctx, studentId))
}

// StudentSearch godoc
//
//	@Summary		Allows you to search the students.
//	@Description	Allows you to search for students by controlling pagination, sorting and filtering results.
//	@Tags			students
//	@Param			x-tenant	header	string					true	"To identify the tenant"
//	@Param			x-cid		header	string					false	"To identify the request"
//	@Param			pagination	query	dtos.PaginationInput	true	"Pagination and sorting"
//	@Param			filter		query	dtos.Filter				false	"Filters"
//	@Accept			json
//	@Produce		json
//	@Success		200	{object}	dtos.Result
//	@Failure		400	{object}	dtos.Result
//	@Failure		500	{object}	dtos.Result
//	@Router			/v1/students [get]
func (h *StudentHandler) Search(ectx echo.Context) error {
	span, ctx := h.Tracer.NewRootSpan(ectx.Request(), tracer.StudentHandlerSearch)
	defer span.End()

	h.Tracer.AddAttributes(span, tracer.StudentHandlerSearch,
		tracer.Attributes{
			"Tenant": ectx.Request().Header.Get(env.ProvideTenantHeaderName()),
		})

	var paginationRequest dtos.PaginationInput
	if err := ectx.Bind(&paginationRequest); err != nil {
		h.Logger.Warn(ctx, "invalid pagination, check the data sent", "error", err.Error())

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	paginationRequest = *dtos.NewPaginationInput(
		paginationRequest.Page,
		paginationRequest.PageSize,
		paginationRequest.SortOrder,
		paginationRequest.SortField,
	)

	h.Tracer.AddAttributes(span, tracer.StudentHandlerSearch,
		tracer.Attributes{
			"Pagination": paginationRequest,
		})

	h.Logger.Debug(ctx, "echo bind pagination ok")

	var filter dtos.Filter
	if err := ectx.Bind(&filter); err != nil {
		h.Logger.Warn(ctx, "invalid filter, check the data sent", "error", err.Error())

		return echo.NewHTTPError(http.StatusBadRequest, dtos.NewBadRequestResult().Message)
	}

	h.Tracer.AddAttributes(span, tracer.StudentHandlerSearch,
		tracer.Attributes{
			"Filter": filter,
		})

	h.Logger.Debug(ctx, "echo bind filter ok")

	return ReturnResult(ectx, h.StudentSearchUseCase.Execute(ctx, paginationRequest, filter))
}


================================================================================
File: internal/adapters/handlers/student_handler_test.go
Size: 15.53 kB
================================================================================

package handlers_test

import (
	"net/http"
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

func TestStudentHandler_Create_WithWrongMethod(t *testing.T) {
	e := builder.Build(t)

	e.PATCH("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusMethodNotAllowed)
}

func TestStudentHandler_Create_WithWrongPath(t *testing.T) {
	e := builder.Build(t)

	e.POST("/v1/studentssss").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound)
}

func TestStudentHandler_Create_WhenTenantIsNotSent(t *testing.T) {
	e := builder.Build(t)

	response := e.POST("/v1/students").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Create_WithErrorBind(t *testing.T) {
	e := builder.Build(t)

	response := e.POST("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		WithJSON("/{}").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Create_WithErrorValidation(t *testing.T) {
	e := builder.Build(t)

	response := e.POST("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentCreateInputInvalid).
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Create_WithStudentAlreadyExists(t *testing.T) {
	e := builder.Build(t)

	response := e.POST("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentCreateInputStored).
		Expect().
		Status(http.StatusConflict).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewConflictResult().Message)
}

func TestStudentHandler_Create_WhenTheStudentsIsCreated(t *testing.T) {
	e := builder.Build(t)

	response := e.POST("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentCreateInput).
		Expect().
		Status(http.StatusCreated).
		JSON().
		Object()

	response.Value("message").IsEqual("The registration was completed successfully.")
	response.Value("data").Object().Value("id").String().NotEmpty()
	response.Value("data").Object().Value("name").IsEqual(f.fakeStudentCreateInput.Name)
}

func TestStudentHandler_Read_WithWrongMethod(t *testing.T) {
	e := builder.Build(t)

	e.PATCH("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusMethodNotAllowed)
}

func TestStudentHandler_Read_WithWrongPath(t *testing.T) {
	e := builder.Build(t)

	e.GET("/v1/studentssss").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound)
}

func TestStudentHandler_Read_WhenTenantIsNotSent(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Read_WhenStudentIsFound(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students/06b2ec25-3fe0-475e-9077-e77a113f4727").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(f.fakeStudent).Message)
	response.Value("data").Object().Value("id").IsEqual(f.fakeStudent.ID)
	response.Value("data").Object().Value("name").IsEqual(f.fakeStudent.Name)
}

func TestStudentHandler_Read_WhenStudentIsNotFound(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students/58ecde02-18f6-4896-a716-64abf6724587").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewNotFoundResult().Message)
}

func TestStudentHandler_Update_WithWrongMethod(t *testing.T) {
	e := builder.Build(t)

	e.PATCH("/v1/students/8e99273f-e566-4476-836e-048b1ecd9c4d").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusMethodNotAllowed)
}

func TestStudentHandler_Update_WithWrongPath(t *testing.T) {
	e := builder.Build(t)

	e.PUT("/v1/studentssss/dbf54856-9a98-4672-9c90-e9da71a1f893").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound)
}

func TestStudentHandler_Update_WhenTenantIsNotSent(t *testing.T) {
	e := builder.Build(t)

	response := e.PUT("/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Update_WithErrorBind(t *testing.T) {
	e := builder.Build(t)

	response := e.PUT("/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893").
		WithHeader("x-tenant", "sbrubles").
		WithJSON("/{}").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Update_WithErrorValidation(t *testing.T) {
	e := builder.Build(t)

	response := e.PUT("/v1/students/dbf54856-9a98-4672-9c90-e9da71a1f893").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentUpdateInputInvalid).
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Update_WithStudentAlreadyExists(t *testing.T) {
	e := builder.Build(t)

	response := e.PUT("/v1/students/06b2ec25-3fe0-475e-9077-e77a113f4727").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentUpdateInputStored).
		Expect().
		Status(http.StatusConflict).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewConflictResult().Message)
}

func TestStudentHandler_Update_WhenTheStudentsIsUpdated(t *testing.T) {
	e := builder.Build(t)

	response := e.PUT("/v1/students/e6e84c46-6ddf-4d9a-b27a-ddb74b4d63bb").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentUpdateInput).
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual("The operation was performed successfully.")
	response.Value("data").Object().Value("id").String().NotEmpty()
	response.Value("data").Object().Value("name").IsEqual(f.fakeStudentUpdateInput.Name)
}

func TestStudentHandler_Delete_WithWrongMethod(t *testing.T) {
	e := builder.Build(t)

	e.PATCH("/v1/students/8e99273f-e566-4476-836e-048b1ecd9c4d").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusMethodNotAllowed)
}

func TestStudentHandler_Delete_WithWrongPath(t *testing.T) {
	e := builder.Build(t)

	e.DELETE("/v1/studentssss/8e99273f-e566-4476-836e-048b1ecd9c4d").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound)
}

func TestStudentHandler_Delete_WhenTenantIsNotSent(t *testing.T) {
	e := builder.Build(t)

	response := e.DELETE("/v1/students/8e99273f-e566-4476-836e-048b1ecd9c4d").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Delete_WithErrorValidation(t *testing.T) {
	e := builder.Build(t)

	response := e.DELETE("/v1/students/1").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Delete_WhenTheStudentsIsDeleted(t *testing.T) {
	e := builder.Build(t)

	e.DELETE("/v1/students/8e99273f-e566-4476-836e-048b1ecd9c4d").
		WithHeader("x-tenant", "sbrubles").
		WithJSON(f.fakeStudentToBeDeleted).
		Expect().
		Status(http.StatusNoContent)
}

func TestStudentHandler_Search_WithWrongMethod(t *testing.T) {
	e := builder.Build(t)

	e.PATCH("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusMethodNotAllowed)
}

func TestStudentHandler_Search_WithWrongPath(t *testing.T) {
	e := builder.Build(t)

	e.GET("/v1/studentssss").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusNotFound)
}

func TestStudentHandler_Search_WhenTenantIsNotSent(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Search_NoPaginationAndNoFilters(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPageOnly(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPageSizeOnly(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("pageSize", 10).
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPageAndPageSize(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithQuery("pageSize", 10).
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPaginationErrorBind(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", "abc").
		WithQuery("pageSize", "def").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusBadRequest).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewBadRequestResult().Message)
}

func TestStudentHandler_Search_IncreasingPagination(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithQuery("pageSize", 3).
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(3)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(3)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPageAndPageSizeEqualToZero(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 0).
		WithQuery("pageSize", 0).
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPageAndPageSizeNegatives(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", -1).
		WithQuery("pageSize", -1).
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPaginationAndSortOrderOnly(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithQuery("pageSize", 10).
		WithQuery("sortOrder", "desc").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPaginationAndSortFieldOnly(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithQuery("pageSize", 10).
		WithQuery("sortField", "name").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPaginationAndOrdination(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithQuery("pageSize", 10).
		WithQuery("sortOrder", "desc").
		WithQuery("sortField", "name").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(7)
}

func TestStudentHandler_Search_WithPaginationAndOrdinationAndFilterByName(t *testing.T) {
	e := builder.Build(t)

	response := e.GET("/v1/students").
		WithQuery("page", 1).
		WithQuery("pageSize", 10).
		WithQuery("sortOrder", "desc").
		WithQuery("sortField", "name").
		WithQuery("name", "thompson").
		WithHeader("x-tenant", "sbrubles").
		Expect().
		Status(http.StatusOK).
		JSON().
		Object()

	response.Value("message").IsEqual(dtos.NewOkResult(nil).Message)
	response.Value("data").Object().Value("total_pages").IsEqual(1)
	response.Value("data").Object().Value("current_page").IsEqual(1)
	response.Value("data").Object().Value("page_size").IsEqual(10)
	response.Value("data").Object().Value("total_items").IsEqual(2)
}


================================================================================
File: internal/adapters/repositories/healthcheck_repository.go
Size: 836 B
================================================================================

package repositories

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/infrastructure/db"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type HealthCheckRepository struct {
	Postgres db.IDb
	Tracer   tracer.ITracer
}

func NewHealthCheckRepository(tracer tracer.ITracer,
	postgres db.IDb) repositories.IHealthCheckRepository {
	return &HealthCheckRepository{
		Postgres: postgres,
		Tracer:   tracer,
	}
}

func (r *HealthCheckRepository) CheckDbConnection(ctx context.Context) error {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.HealthCheckRepositoryCheckDbConnection)
	defer span.End()

	var result int
	row := r.Postgres.QueryRowContext(ctx, "SELECT 1")

	if err := row.Scan(&result); err != nil {
		return err
	}

	return nil
}


================================================================================
File: internal/adapters/repositories/healthcheck_repository_test.go
Size: 493 B
================================================================================

package repositories_test

import (
	"testing"

	_ "github.com/lib/pq"
	"github.com/stretchr/testify/assert"
)

func TestHealthCheckRepository_CheckDbConnection_Success(t *testing.T) {
	sut := builder.BuildHealthCheckRepository()

	err := sut.CheckDbConnection(builder.Ctx)

	assert.NoError(t, err)
}

func TestHealthCheckRepository_CheckDbConnection_Fails(t *testing.T) {
	sut := failedBuilder.BuildHealthCheckRepository()

	err := sut.CheckDbConnection(builder.Ctx)

	assert.Error(t, err)
}


================================================================================
File: internal/adapters/repositories/main_test.go
Size: 1.5 kB
================================================================================

package repositories_test

import (
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/domain/entities"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
)

type fakeValues struct {
	fakeNewStudent         *entities.Student
	fakeStoredStudent      *entities.Student
	fakeNotFoundStudent    *entities.Student
	fakeStudentToBeDeleted string
}

var f *fakeValues
var builder *tests.IntegrationTestsBuilder
var failedBuilder *tests.IntegrationTestsBuilder

// TestMain will run before all the tests in the package repositories_test
func TestMain(m *testing.M) {
	// Setup: Create the builder and initialize the container
	builder = tests.
		NewIntegrationTestsBuilder().
		WithLogger().
		WithTracer()

	failedBuilder = tests.
		NewFailedIntegrationTestsBuilder().
		WithLogger().
		WithTracer()

	f = &fakeValues{
		fakeNewStudent: &entities.Student{
			ID:   "ef9a11c4-9603-4995-b386-37ed45365eb6",
			Name: "john doe",
		},
		fakeStoredStudent: &entities.Student{
			ID:   "06b2ec25-3fe0-475e-9077-e77a113f4727",
			Name: "alice",
		},
		fakeNotFoundStudent: &entities.Student{
			ID:   "58ecde02-18f6-4896-a716-64abf6724587",
			Name: "jordan",
		},
		fakeStudentToBeDeleted: "8e99273f-e566-4476-836e-048b1ecd9c4d",
	}

	// Run all tests in repositories_test
	code := m.Run()

	// Teardown: Stop the container after all tests
	func() {
		builder.DbConn.Close()
		builder.PgContainer.Terminate(builder.Ctx)
	}()

	// Exit with the code returned by the tests
	os.Exit(code)
}


================================================================================
File: internal/adapters/repositories/student_repository.go
Size: 5.13 kB
================================================================================

package repositories

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/infrastructure/db"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentRepository struct {
	Postgres db.IDb
	Tracer   tracer.ITracer
}

func NewStudentRepository(tracer tracer.ITracer,
	postgres db.IDb) repositories.IStudentRepository {
	return &StudentRepository{
		Postgres: postgres,
		Tracer:   tracer,
	}
}

func (r *StudentRepository) Add(ctx context.Context, student *entities.Student) error {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositoryAdd)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositoryAdd,
		tracer.Attributes{
			"Entity": student,
		})

	_, err := r.Postgres.ExecContext(ctx, "INSERT INTO students (id, name) VALUES ($1, $2)", student.ID, student.Name)

	return err
}

func (r *StudentRepository) ExistsByName(ctx context.Context, name string) (bool, error) {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositoryExistsByName)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositoryExistsByName,
		tracer.Attributes{
			"Name": name,
		})

	var exists bool

	err := r.Postgres.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM students WHERE name = $1)", name).Scan(&exists)
	return exists, err
}

func (r *StudentRepository) FindById(ctx context.Context, studentId string) (*entities.Student, error) {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositoryFindById)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositoryFindById,
		tracer.Attributes{
			"ID": studentId,
		})

	row := r.Postgres.QueryRowContext(ctx, "SELECT Id, Name FROM students WHERE Id = $1", studentId)

	var student entities.Student
	err := row.Scan(&student.ID, &student.Name)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}

		return nil, err
	}

	return &student, nil
}

func (r *StudentRepository) Update(ctx context.Context, student *entities.Student) error {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositoryUpdate)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositoryUpdate,
		tracer.Attributes{
			"Entity": student,
		})

	_, err := r.Postgres.ExecContext(ctx, "UPDATE students SET name = $1 WHERE id = $2", student.Name, student.ID)

	return err
}

func (r *StudentRepository) Delete(ctx context.Context, studentId string) error {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositoryDelete)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositoryDelete,
		tracer.Attributes{
			"ID": studentId,
		})

	_, err := r.Postgres.ExecContext(ctx, "DELETE FROM students WHERE id = $1", studentId)

	return err
}

func (r *StudentRepository) Count(ctx context.Context, filter dtos.Filter) (int, error) {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositoryCount)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositoryCount,
		tracer.Attributes{
			"Filter": filter,
		})

	query := "SELECT COUNT(*) FROM students"
	args := make([]interface{}, 0)

	if filter.Name != nil {
		query += " WHERE name LIKE $1"
		args = append(args, fmt.Sprintf("%%%s%%", *filter.Name))
	}

	var count int

	err := r.Postgres.QueryRowContext(ctx, query, args[:]...).Scan(&count)
	return count, err
}

func (r *StudentRepository) SearchBy(ctx context.Context, pagination dtos.PaginationInput, filter dtos.Filter) ([]*entities.Student, error) {
	span, ctx := r.Tracer.NewSpanContext(ctx, tracer.StudentRepositorySearchBy)
	defer span.End()

	r.Tracer.AddAttributes(span, tracer.StudentRepositorySearchBy,
		tracer.Attributes{
			"Pagination": pagination,
			"Filter":     filter,
		})

	query := "SELECT id, name FROM students"
	args := make([]interface{}, 0)
	placeholder := 1

	if filter.Name != nil {
		query += fmt.Sprintf(" WHERE name LIKE $%d", placeholder)
		args = append(args, fmt.Sprintf("%%%s%%", *filter.Name))
		placeholder++
	}

	if pagination.SortField != nil {
		if strings.EqualFold(*pagination.SortField, dtos.FILTER_NAME) {
			query += " ORDER BY name "
		} else {
			query += " ORDER BY id "
		}
	}

	if pagination.SortField != nil && pagination.SortOrder != nil {
		if pagination.IsASC() {
			query += dtos.ORDER_ASC
		} else {
			query += dtos.ORDER_DESC
		}
	}

	query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", placeholder, placeholder+1)
	args = append(args, pagination.PageSize, pagination.Offset())

	rows, err := r.Postgres.QueryContext(ctx, query, args[:]...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	var students []*entities.Student
	for rows.Next() {
		var student entities.Student

		err := rows.Scan(&student.ID, &student.Name)
		if err != nil {
			if err == sql.ErrNoRows {
				return nil, nil
			}

			return nil, err
		}

		students = append(students, &student)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	return students, nil
}


================================================================================
File: internal/adapters/repositories/student_repository_test.go
Size: 6.3 kB
================================================================================

package repositories_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	_ "github.com/lib/pq"
	"github.com/stretchr/testify/assert"
)

func TestStudentRepository_Add_WhenRepositoryAddsTheStudent(t *testing.T) {
	sut := builder.BuildStudentRepository()

	err := sut.Add(builder.Ctx, f.fakeNewStudent)

	assert.NoError(t, err)
}

func TestStudentRepository_Add_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	err := sut.Add(builder.Ctx, f.fakeNewStudent)

	assert.Error(t, err)
}

func TestStudentRepository_ExistsByName_WhenTheStudentAlreadyExists(t *testing.T) {
	sut := builder.BuildStudentRepository()

	exists, err := sut.ExistsByName(builder.Ctx, f.fakeStoredStudent.Name)

	assert.NoError(t, err)
	assert.True(t, exists)
}

func TestStudentRepository_ExistsByName_WhenTheStudentDoesNotExist(t *testing.T) {
	sut := builder.BuildStudentRepository()

	exists, err := sut.ExistsByName(builder.Ctx, f.fakeNewStudent.Name+"1")

	assert.NoError(t, err)
	assert.False(t, exists)
}

func TestStudentRepository_ExistsByName_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	exists, err := sut.ExistsByName(builder.Ctx, f.fakeStoredStudent.ID)

	assert.Error(t, err)
	assert.False(t, exists)
}

func TestStudentRepository_FindById_WhenTheStudentIsNotFound(t *testing.T) {
	sut := builder.BuildStudentRepository()

	student, err := sut.FindById(builder.Ctx, f.fakeNotFoundStudent.ID)

	assert.NoError(t, err)
	assert.Nil(t, student)
}

func TestStudentRepository_FindById_WhenTheStudentIsFound(t *testing.T) {
	sut := builder.BuildStudentRepository()

	student, err := sut.FindById(builder.Ctx, f.fakeStoredStudent.ID)

	assert.NoError(t, err)
	assert.EqualValues(t, student, f.fakeStoredStudent)
}

func TestStudentRepository_FindById_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	student, err := sut.FindById(builder.Ctx, f.fakeStoredStudent.ID)

	assert.Error(t, err)
	assert.Nil(t, student)
}

func TestStudentRepository_Update_WhenRepositoryUpdatesTheStudent(t *testing.T) {
	sut := builder.BuildStudentRepository()

	err := sut.Update(builder.Ctx, f.fakeNewStudent)

	assert.NoError(t, err)
}

func TestStudentRepository_Update_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	err := sut.Update(builder.Ctx, f.fakeNewStudent)

	assert.Error(t, err)
}

func TestStudentRepository_Delete_WhenRepositoryRemovesTheStudent(t *testing.T) {
	sut := builder.BuildStudentRepository()

	err := sut.Delete(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.NoError(t, err)
}

func TestStudentRepository_Delete_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	err := sut.Delete(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.Error(t, err)
}

func TestStudentRepository_SearchBy_WhenRepositoryReturnsOnePageOfData(t *testing.T) {
	sut := builder.BuildStudentRepository()

	results, err := sut.SearchBy(builder.Ctx,
		dtos.PaginationInput{
			Page:      1,
			PageSize:  10,
			SortOrder: tests.ToPointer("asc"),
			SortField: tests.ToPointer("name"),
		},
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.NoError(t, err)
	assert.Len(t, results, 2)
	assert.Equal(t, results[0].Name, "michael thompson")
	assert.Equal(t, results[1].Name, "will thompson")

	results, err = sut.SearchBy(builder.Ctx,
		dtos.PaginationInput{
			Page:      2,
			PageSize:  10,
			SortOrder: tests.ToPointer("asc"),
			SortField: tests.ToPointer("name"),
		},
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.NoError(t, err)
	assert.Len(t, results, 0)
}

func TestStudentRepository_SearchBy_WhenRepositoryReturnsTwoPageOfData(t *testing.T) {
	sut := builder.BuildStudentRepository()

	results, err := sut.SearchBy(builder.Ctx,
		dtos.PaginationInput{
			Page:      1,
			PageSize:  1,
			SortOrder: tests.ToPointer("asc"),
			SortField: tests.ToPointer("name"),
		},
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.NoError(t, err)
	assert.Len(t, results, 1)
	assert.Equal(t, results[0].Name, "michael thompson")

	results, err = sut.SearchBy(builder.Ctx,
		dtos.PaginationInput{
			Page:      2,
			PageSize:  1,
			SortOrder: tests.ToPointer("asc"),
			SortField: tests.ToPointer("name"),
		},
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.NoError(t, err)
	assert.Len(t, results, 1)
	assert.Equal(t, results[0].Name, "will thompson")
}

func TestStudentRepository_SearchBy_ToSortOrderDescAndSortFieldId(t *testing.T) {
	sut := builder.BuildStudentRepository()

	results, err := sut.SearchBy(builder.Ctx,
		dtos.PaginationInput{
			Page:      1,
			PageSize:  10,
			SortOrder: tests.ToPointer("desc"),
			SortField: tests.ToPointer("id"),
		},
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.NoError(t, err)
	assert.Len(t, results, 2)
	assert.Equal(t, results[0].Name, "will thompson")
	assert.Equal(t, results[1].Name, "michael thompson")
}

func TestStudentRepository_SearchBy_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	results, err := sut.SearchBy(builder.Ctx,
		dtos.PaginationInput{
			Page:      1,
			PageSize:  10,
			SortOrder: tests.ToPointer("asc"),
			SortField: tests.ToPointer("name"),
		},
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.Error(t, err)
	assert.Nil(t, results)
}

func TestStudentRepository_Count_WhenRepositoryReturnsCount(t *testing.T) {
	sut := builder.BuildStudentRepository()

	count, err := sut.Count(builder.Ctx,
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.NoError(t, err)
	assert.Equal(t, count, 2)
}

func TestStudentRepository_Count_WhenRepositoryReturnsZero(t *testing.T) {
	sut := builder.BuildStudentRepository()

	count, err := sut.Count(builder.Ctx,
		dtos.Filter{
			Name: tests.ToPointer("sbrubles"),
		},
	)

	assert.NoError(t, err)
	assert.Zero(t, count)
}

func TestStudentRepository_Count_WhenTheQueryFails(t *testing.T) {
	sut := failedBuilder.BuildStudentRepository()

	count, err := sut.Count(builder.Ctx,
		dtos.Filter{
			Name: tests.ToPointer("thompson"),
		},
	)

	assert.Error(t, err)
	assert.Zero(t, count)
}


================================================================================
File: internal/domain/dtos/field.go
Size: 61 B
================================================================================

package dtos

type Field struct {
	Key   string
	Value any
}


================================================================================
File: internal/domain/dtos/filter.go
Size: 99 B
================================================================================

package dtos

const (
	FILTER_NAME = "name"
)

type Filter struct {
	Name *string `query:"name"`
}


================================================================================
File: internal/domain/dtos/pagination.go
Size: 1.85 kB
================================================================================

package dtos

import "strings"

const (
	PAGE                    = "page"
	PAGE_SIZE               = "pageSize"
	SORT_ORDER              = "sortOrder"
	SORT_FIELD              = "sortField"
	ORDER_ASC               = "ASC"
	ORDER_DESC              = "DESC"
	DEFAULT_PAGE_VALUE      = 1
	DEFAULT_PAGE_SIZE_VALUE = 10
)

type (
	PaginationInput struct {
		Page      int     `query:"page"`
		PageSize  int     `query:"pageSize"`
		SortOrder *string `query:"sortOrder"`
		SortField *string `query:"sortField"`
	}

	PaginationOutput struct {
		TotalPages  int         `json:"total_pages"`
		CurrentPage int         `json:"current_page"`
		PageSize    int         `json:"page_size"`
		TotalItems  int         `json:"total_items"`
		Items       interface{} `json:"items"`
	}
)

func NewPaginationInput(page, pageSize int, sortOrder, sortField *string) *PaginationInput {
	if page <= 0 {
		page = DEFAULT_PAGE_VALUE
	}

	if pageSize <= 0 {
		pageSize = DEFAULT_PAGE_SIZE_VALUE
	}

	return &PaginationInput{
		Page:      page,
		PageSize:  pageSize,
		SortOrder: sortOrder,
		SortField: sortField,
	}
}

func NewPaginationOutput(totalItems, currentPage, pageSize int, items interface{}) *PaginationOutput {
	if pageSize <= 0 {
		pageSize = DEFAULT_PAGE_SIZE_VALUE
	}

	if totalItems <= 0 {
		return &PaginationOutput{
			TotalPages:  DEFAULT_PAGE_VALUE,
			CurrentPage: DEFAULT_PAGE_VALUE,
			PageSize:    pageSize,
			TotalItems:  totalItems,
			Items:       items,
		}
	}

	return &PaginationOutput{
		TotalPages:  (totalItems + pageSize - 1) / pageSize,
		CurrentPage: currentPage,
		PageSize:    pageSize,
		TotalItems:  totalItems,
		Items:       items,
	}
}

func (p *PaginationInput) IsASC() bool {
	return *p.SortOrder == "" || strings.EqualFold(ORDER_ASC, *p.SortOrder)
}

func (p *PaginationInput) Offset() int {
	return (p.Page - 1) * p.PageSize
}


================================================================================
File: internal/domain/dtos/request_context.go
Size: 79 B
================================================================================

package dtos

type RequestContext struct {
	TenantId string
	Cid      string
}


================================================================================
File: internal/domain/dtos/result.go
Size: 1.59 kB
================================================================================

package dtos

type Result struct {
	Code    int    `json:"-"`
	Message string `json:"message"`
	Data    any    `json:"data,omitempty"`
}

func newSuccessResult(code int, data any, message string) *Result {
	return &Result{
		Code:    code,
		Message: message,
		Data:    data,
	}
}

func newWarningResult(code int, message string) *Result {
	return &Result{
		Code:    code,
		Message: message,
		Data:    nil,
	}
}

func newErrorResult(code int, errMessage string) *Result {
	return &Result{
		Code:    code,
		Message: errMessage,
		Data:    nil,
	}
}

func NewOkResult(data any) *Result {
	return newSuccessResult(
		200,
		data,
		"The operation was performed successfully.",
	)
}

func NewCreatedResult(data any) *Result {
	return newSuccessResult(
		201,
		data,
		"The registration was completed successfully.",
	)
}

func NewNoCotentResult() *Result {
	return newSuccessResult(
		204,
		nil,
		"",
	)
}

func NewBadRequestResult() *Result {
	return newWarningResult(
		400,
		"The request does not meet the expected format. Please check the data and try again.",
	)
}

func NewNotFoundResult() *Result {
	return newWarningResult(
		404,
		"The target was not found.",
	)
}

func NewConflictResult() *Result {
	return newWarningResult(
		409,
		"The target already exists.",
	)
}

func NewInternalServerErrorResult() *Result {
	return newErrorResult(
		500,
		"Sorry, something went wrong in our system. Please try again later.",
	)
}

func NewGatewayTimeoutErrorResult() *Result {
	return newErrorResult(
		504,
		"The server took too long to respond. Please try again later.",
	)
}


================================================================================
File: internal/domain/dtos/student.go
Size: 307 B
================================================================================

package dtos

type (
	StudentCreateInput struct {
		Name string `json:"name" validate:"required,max=200"`
	}

	StudentUpdateInput struct {
		ID   string `json:"-"`
		Name string `json:"name" validate:"required,max=200"`
	}

	StudentOutput struct {
		ID   string `json:"id"`
		Name string `json:"name"`
	}
)


================================================================================
File: internal/domain/entities/student.go
Size: 238 B
================================================================================

package entities

import "github.com/dmarins/student-api/internal/infrastructure/uuid"

type Student struct {
	ID   string
	Name string
}

func NewStudent(name string) *Student {
	return &Student{
		ID:   uuid.NewId(),
		Name: name,
	}
}


================================================================================
File: internal/domain/mocks/healthcheck.go
Size: 2.61 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecases/healthcheck.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/usecases/healthcheck.go -destination=internal/domain/mocks/healthcheck.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dtos "github.com/dmarins/student-api/internal/domain/dtos"
	gomock "go.uber.org/mock/gomock"
)

// MockIHealthCheckUseCase is a mock of IHealthCheckUseCase interface.
type MockIHealthCheckUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIHealthCheckUseCaseMockRecorder
	isgomock struct{}
}

// MockIHealthCheckUseCaseMockRecorder is the mock recorder for MockIHealthCheckUseCase.
type MockIHealthCheckUseCaseMockRecorder struct {
	mock *MockIHealthCheckUseCase
}

// NewMockIHealthCheckUseCase creates a new mock instance.
func NewMockIHealthCheckUseCase(ctrl *gomock.Controller) *MockIHealthCheckUseCase {
	mock := &MockIHealthCheckUseCase{ctrl: ctrl}
	mock.recorder = &MockIHealthCheckUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIHealthCheckUseCase) EXPECT() *MockIHealthCheckUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockIHealthCheckUseCase) Execute(ctx context.Context) *dtos.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx)
	ret0, _ := ret[0].(*dtos.Result)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockIHealthCheckUseCaseMockRecorder) Execute(ctx any) *MockIHealthCheckUseCaseExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockIHealthCheckUseCase)(nil).Execute), ctx)
	return &MockIHealthCheckUseCaseExecuteCall{Call: call}
}

// MockIHealthCheckUseCaseExecuteCall wrap *gomock.Call
type MockIHealthCheckUseCaseExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIHealthCheckUseCaseExecuteCall) Return(arg0 *dtos.Result) *MockIHealthCheckUseCaseExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIHealthCheckUseCaseExecuteCall) Do(f func(context.Context) *dtos.Result) *MockIHealthCheckUseCaseExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIHealthCheckUseCaseExecuteCall) DoAndReturn(f func(context.Context) *dtos.Result) *MockIHealthCheckUseCaseExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/healthcheck_repository.go
Size: 2.82 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/repositories/healthcheck_repository.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/repositories/healthcheck_repository.go -destination=internal/domain/mocks/healthcheck_repository.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockIHealthCheckRepository is a mock of IHealthCheckRepository interface.
type MockIHealthCheckRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIHealthCheckRepositoryMockRecorder
	isgomock struct{}
}

// MockIHealthCheckRepositoryMockRecorder is the mock recorder for MockIHealthCheckRepository.
type MockIHealthCheckRepositoryMockRecorder struct {
	mock *MockIHealthCheckRepository
}

// NewMockIHealthCheckRepository creates a new mock instance.
func NewMockIHealthCheckRepository(ctrl *gomock.Controller) *MockIHealthCheckRepository {
	mock := &MockIHealthCheckRepository{ctrl: ctrl}
	mock.recorder = &MockIHealthCheckRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIHealthCheckRepository) EXPECT() *MockIHealthCheckRepositoryMockRecorder {
	return m.recorder
}

// CheckDbConnection mocks base method.
func (m *MockIHealthCheckRepository) CheckDbConnection(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckDbConnection", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckDbConnection indicates an expected call of CheckDbConnection.
func (mr *MockIHealthCheckRepositoryMockRecorder) CheckDbConnection(ctx any) *MockIHealthCheckRepositoryCheckDbConnectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckDbConnection", reflect.TypeOf((*MockIHealthCheckRepository)(nil).CheckDbConnection), ctx)
	return &MockIHealthCheckRepositoryCheckDbConnectionCall{Call: call}
}

// MockIHealthCheckRepositoryCheckDbConnectionCall wrap *gomock.Call
type MockIHealthCheckRepositoryCheckDbConnectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIHealthCheckRepositoryCheckDbConnectionCall) Return(arg0 error) *MockIHealthCheckRepositoryCheckDbConnectionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIHealthCheckRepositoryCheckDbConnectionCall) Do(f func(context.Context) error) *MockIHealthCheckRepositoryCheckDbConnectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIHealthCheckRepositoryCheckDbConnectionCall) DoAndReturn(f func(context.Context) error) *MockIHealthCheckRepositoryCheckDbConnectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/logger.go
Size: 8.3 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/infrastructure/logger/logger.go
//
// Generated by this command:
//
//	mockgen -source=internal/infrastructure/logger/logger.go -destination=internal/domain/mocks/logger.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockILogger is a mock of ILogger interface.
type MockILogger struct {
	ctrl     *gomock.Controller
	recorder *MockILoggerMockRecorder
	isgomock struct{}
}

// MockILoggerMockRecorder is the mock recorder for MockILogger.
type MockILoggerMockRecorder struct {
	mock *MockILogger
}

// NewMockILogger creates a new mock instance.
func NewMockILogger(ctrl *gomock.Controller) *MockILogger {
	mock := &MockILogger{ctrl: ctrl}
	mock.recorder = &MockILoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILogger) EXPECT() *MockILoggerMockRecorder {
	return m.recorder
}

// Debug mocks base method.
func (m *MockILogger) Debug(ctx context.Context, msg string, fields ...string) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, msg}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Debug", varargs...)
}

// Debug indicates an expected call of Debug.
func (mr *MockILoggerMockRecorder) Debug(ctx, msg any, fields ...any) *MockILoggerDebugCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, msg}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockILogger)(nil).Debug), varargs...)
	return &MockILoggerDebugCall{Call: call}
}

// MockILoggerDebugCall wrap *gomock.Call
type MockILoggerDebugCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockILoggerDebugCall) Return() *MockILoggerDebugCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockILoggerDebugCall) Do(f func(context.Context, string, ...string)) *MockILoggerDebugCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockILoggerDebugCall) DoAndReturn(f func(context.Context, string, ...string)) *MockILoggerDebugCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Error mocks base method.
func (m *MockILogger) Error(ctx context.Context, msg string, err error, fields ...string) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, msg, err}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Error", varargs...)
}

// Error indicates an expected call of Error.
func (mr *MockILoggerMockRecorder) Error(ctx, msg, err any, fields ...any) *MockILoggerErrorCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, msg, err}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockILogger)(nil).Error), varargs...)
	return &MockILoggerErrorCall{Call: call}
}

// MockILoggerErrorCall wrap *gomock.Call
type MockILoggerErrorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockILoggerErrorCall) Return() *MockILoggerErrorCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockILoggerErrorCall) Do(f func(context.Context, string, error, ...string)) *MockILoggerErrorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockILoggerErrorCall) DoAndReturn(f func(context.Context, string, error, ...string)) *MockILoggerErrorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Fatal mocks base method.
func (m *MockILogger) Fatal(ctx context.Context, msg string, err error, fields ...string) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, msg, err}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Fatal", varargs...)
}

// Fatal indicates an expected call of Fatal.
func (mr *MockILoggerMockRecorder) Fatal(ctx, msg, err any, fields ...any) *MockILoggerFatalCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, msg, err}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fatal", reflect.TypeOf((*MockILogger)(nil).Fatal), varargs...)
	return &MockILoggerFatalCall{Call: call}
}

// MockILoggerFatalCall wrap *gomock.Call
type MockILoggerFatalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockILoggerFatalCall) Return() *MockILoggerFatalCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockILoggerFatalCall) Do(f func(context.Context, string, error, ...string)) *MockILoggerFatalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockILoggerFatalCall) DoAndReturn(f func(context.Context, string, error, ...string)) *MockILoggerFatalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Info mocks base method.
func (m *MockILogger) Info(ctx context.Context, msg string, fields ...string) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, msg}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Info", varargs...)
}

// Info indicates an expected call of Info.
func (mr *MockILoggerMockRecorder) Info(ctx, msg any, fields ...any) *MockILoggerInfoCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, msg}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockILogger)(nil).Info), varargs...)
	return &MockILoggerInfoCall{Call: call}
}

// MockILoggerInfoCall wrap *gomock.Call
type MockILoggerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockILoggerInfoCall) Return() *MockILoggerInfoCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockILoggerInfoCall) Do(f func(context.Context, string, ...string)) *MockILoggerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockILoggerInfoCall) DoAndReturn(f func(context.Context, string, ...string)) *MockILoggerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sync mocks base method.
func (m *MockILogger) Sync(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Sync", ctx)
}

// Sync indicates an expected call of Sync.
func (mr *MockILoggerMockRecorder) Sync(ctx any) *MockILoggerSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sync", reflect.TypeOf((*MockILogger)(nil).Sync), ctx)
	return &MockILoggerSyncCall{Call: call}
}

// MockILoggerSyncCall wrap *gomock.Call
type MockILoggerSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockILoggerSyncCall) Return() *MockILoggerSyncCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockILoggerSyncCall) Do(f func(context.Context)) *MockILoggerSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockILoggerSyncCall) DoAndReturn(f func(context.Context)) *MockILoggerSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Warn mocks base method.
func (m *MockILogger) Warn(ctx context.Context, msg string, fields ...string) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, msg}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Warn", varargs...)
}

// Warn indicates an expected call of Warn.
func (mr *MockILoggerMockRecorder) Warn(ctx, msg any, fields ...any) *MockILoggerWarnCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, msg}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockILogger)(nil).Warn), varargs...)
	return &MockILoggerWarnCall{Call: call}
}

// MockILoggerWarnCall wrap *gomock.Call
type MockILoggerWarnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockILoggerWarnCall) Return() *MockILoggerWarnCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockILoggerWarnCall) Do(f func(context.Context, string, ...string)) *MockILoggerWarnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockILoggerWarnCall) DoAndReturn(f func(context.Context, string, ...string)) *MockILoggerWarnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/span_wrapper.go
Size: 3.09 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/infrastructure/tracer/span_wrapper.go
//
// Generated by this command:
//
//	mockgen -source=internal/infrastructure/tracer/span_wrapper.go -destination=internal/domain/mocks/span_wrapper.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockISpan is a mock of ISpan interface.
type MockISpan struct {
	ctrl     *gomock.Controller
	recorder *MockISpanMockRecorder
	isgomock struct{}
}

// MockISpanMockRecorder is the mock recorder for MockISpan.
type MockISpanMockRecorder struct {
	mock *MockISpan
}

// NewMockISpan creates a new mock instance.
func NewMockISpan(ctrl *gomock.Controller) *MockISpan {
	mock := &MockISpan{ctrl: ctrl}
	mock.recorder = &MockISpanMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISpan) EXPECT() *MockISpanMockRecorder {
	return m.recorder
}

// AddEvent mocks base method.
func (m *MockISpan) AddEvent(name string, opts ...any) {
	m.ctrl.T.Helper()
	varargs := []any{name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "AddEvent", varargs...)
}

// AddEvent indicates an expected call of AddEvent.
func (mr *MockISpanMockRecorder) AddEvent(name any, opts ...any) *MockISpanAddEventCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEvent", reflect.TypeOf((*MockISpan)(nil).AddEvent), varargs...)
	return &MockISpanAddEventCall{Call: call}
}

// MockISpanAddEventCall wrap *gomock.Call
type MockISpanAddEventCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockISpanAddEventCall) Return() *MockISpanAddEventCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockISpanAddEventCall) Do(f func(string, ...any)) *MockISpanAddEventCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockISpanAddEventCall) DoAndReturn(f func(string, ...any)) *MockISpanAddEventCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// End mocks base method.
func (m *MockISpan) End() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "End")
}

// End indicates an expected call of End.
func (mr *MockISpanMockRecorder) End() *MockISpanEndCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "End", reflect.TypeOf((*MockISpan)(nil).End))
	return &MockISpanEndCall{Call: call}
}

// MockISpanEndCall wrap *gomock.Call
type MockISpanEndCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockISpanEndCall) Return() *MockISpanEndCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockISpanEndCall) Do(f func()) *MockISpanEndCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockISpanEndCall) DoAndReturn(f func()) *MockISpanEndCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/student_create.go
Size: 2.83 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecases/student_create.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/usecases/student_create.go -destination=internal/domain/mocks/student_create.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dtos "github.com/dmarins/student-api/internal/domain/dtos"
	gomock "go.uber.org/mock/gomock"
)

// MockIStudentCreateUseCase is a mock of IStudentCreateUseCase interface.
type MockIStudentCreateUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIStudentCreateUseCaseMockRecorder
	isgomock struct{}
}

// MockIStudentCreateUseCaseMockRecorder is the mock recorder for MockIStudentCreateUseCase.
type MockIStudentCreateUseCaseMockRecorder struct {
	mock *MockIStudentCreateUseCase
}

// NewMockIStudentCreateUseCase creates a new mock instance.
func NewMockIStudentCreateUseCase(ctrl *gomock.Controller) *MockIStudentCreateUseCase {
	mock := &MockIStudentCreateUseCase{ctrl: ctrl}
	mock.recorder = &MockIStudentCreateUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStudentCreateUseCase) EXPECT() *MockIStudentCreateUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockIStudentCreateUseCase) Execute(ctx context.Context, studentCreateInput dtos.StudentCreateInput) *dtos.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, studentCreateInput)
	ret0, _ := ret[0].(*dtos.Result)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockIStudentCreateUseCaseMockRecorder) Execute(ctx, studentCreateInput any) *MockIStudentCreateUseCaseExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockIStudentCreateUseCase)(nil).Execute), ctx, studentCreateInput)
	return &MockIStudentCreateUseCaseExecuteCall{Call: call}
}

// MockIStudentCreateUseCaseExecuteCall wrap *gomock.Call
type MockIStudentCreateUseCaseExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentCreateUseCaseExecuteCall) Return(arg0 *dtos.Result) *MockIStudentCreateUseCaseExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentCreateUseCaseExecuteCall) Do(f func(context.Context, dtos.StudentCreateInput) *dtos.Result) *MockIStudentCreateUseCaseExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentCreateUseCaseExecuteCall) DoAndReturn(f func(context.Context, dtos.StudentCreateInput) *dtos.Result) *MockIStudentCreateUseCaseExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/student_delete.go
Size: 2.74 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecases/student_delete.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/usecases/student_delete.go -destination=internal/domain/mocks/student_delete.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dtos "github.com/dmarins/student-api/internal/domain/dtos"
	gomock "go.uber.org/mock/gomock"
)

// MockIStudentDeleteUseCase is a mock of IStudentDeleteUseCase interface.
type MockIStudentDeleteUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIStudentDeleteUseCaseMockRecorder
	isgomock struct{}
}

// MockIStudentDeleteUseCaseMockRecorder is the mock recorder for MockIStudentDeleteUseCase.
type MockIStudentDeleteUseCaseMockRecorder struct {
	mock *MockIStudentDeleteUseCase
}

// NewMockIStudentDeleteUseCase creates a new mock instance.
func NewMockIStudentDeleteUseCase(ctrl *gomock.Controller) *MockIStudentDeleteUseCase {
	mock := &MockIStudentDeleteUseCase{ctrl: ctrl}
	mock.recorder = &MockIStudentDeleteUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStudentDeleteUseCase) EXPECT() *MockIStudentDeleteUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockIStudentDeleteUseCase) Execute(ctx context.Context, studentId string) *dtos.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, studentId)
	ret0, _ := ret[0].(*dtos.Result)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockIStudentDeleteUseCaseMockRecorder) Execute(ctx, studentId any) *MockIStudentDeleteUseCaseExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockIStudentDeleteUseCase)(nil).Execute), ctx, studentId)
	return &MockIStudentDeleteUseCaseExecuteCall{Call: call}
}

// MockIStudentDeleteUseCaseExecuteCall wrap *gomock.Call
type MockIStudentDeleteUseCaseExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentDeleteUseCaseExecuteCall) Return(arg0 *dtos.Result) *MockIStudentDeleteUseCaseExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentDeleteUseCaseExecuteCall) Do(f func(context.Context, string) *dtos.Result) *MockIStudentDeleteUseCaseExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentDeleteUseCaseExecuteCall) DoAndReturn(f func(context.Context, string) *dtos.Result) *MockIStudentDeleteUseCaseExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/student_read.go
Size: 5.06 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecases/student_read.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/usecases/student_read.go -destination=internal/domain/mocks/student_read.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dtos "github.com/dmarins/student-api/internal/domain/dtos"
	gomock "go.uber.org/mock/gomock"
)

// MockIStudentReadUseCase is a mock of IStudentReadUseCase interface.
type MockIStudentReadUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIStudentReadUseCaseMockRecorder
	isgomock struct{}
}

// MockIStudentReadUseCaseMockRecorder is the mock recorder for MockIStudentReadUseCase.
type MockIStudentReadUseCaseMockRecorder struct {
	mock *MockIStudentReadUseCase
}

// NewMockIStudentReadUseCase creates a new mock instance.
func NewMockIStudentReadUseCase(ctrl *gomock.Controller) *MockIStudentReadUseCase {
	mock := &MockIStudentReadUseCase{ctrl: ctrl}
	mock.recorder = &MockIStudentReadUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStudentReadUseCase) EXPECT() *MockIStudentReadUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockIStudentReadUseCase) Execute(ctx context.Context, studentId string) *dtos.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, studentId)
	ret0, _ := ret[0].(*dtos.Result)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockIStudentReadUseCaseMockRecorder) Execute(ctx, studentId any) *MockIStudentReadUseCaseExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockIStudentReadUseCase)(nil).Execute), ctx, studentId)
	return &MockIStudentReadUseCaseExecuteCall{Call: call}
}

// MockIStudentReadUseCaseExecuteCall wrap *gomock.Call
type MockIStudentReadUseCaseExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentReadUseCaseExecuteCall) Return(arg0 *dtos.Result) *MockIStudentReadUseCaseExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentReadUseCaseExecuteCall) Do(f func(context.Context, string) *dtos.Result) *MockIStudentReadUseCaseExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentReadUseCaseExecuteCall) DoAndReturn(f func(context.Context, string) *dtos.Result) *MockIStudentReadUseCaseExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockIStudentSearchUseCase is a mock of IStudentSearchUseCase interface.
type MockIStudentSearchUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIStudentSearchUseCaseMockRecorder
	isgomock struct{}
}

// MockIStudentSearchUseCaseMockRecorder is the mock recorder for MockIStudentSearchUseCase.
type MockIStudentSearchUseCaseMockRecorder struct {
	mock *MockIStudentSearchUseCase
}

// NewMockIStudentSearchUseCase creates a new mock instance.
func NewMockIStudentSearchUseCase(ctrl *gomock.Controller) *MockIStudentSearchUseCase {
	mock := &MockIStudentSearchUseCase{ctrl: ctrl}
	mock.recorder = &MockIStudentSearchUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStudentSearchUseCase) EXPECT() *MockIStudentSearchUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockIStudentSearchUseCase) Execute(ctx context.Context, pagination dtos.PaginationInput, filter dtos.Filter) *dtos.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, pagination, filter)
	ret0, _ := ret[0].(*dtos.Result)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockIStudentSearchUseCaseMockRecorder) Execute(ctx, pagination, filter any) *MockIStudentSearchUseCaseExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockIStudentSearchUseCase)(nil).Execute), ctx, pagination, filter)
	return &MockIStudentSearchUseCaseExecuteCall{Call: call}
}

// MockIStudentSearchUseCaseExecuteCall wrap *gomock.Call
type MockIStudentSearchUseCaseExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentSearchUseCaseExecuteCall) Return(arg0 *dtos.Result) *MockIStudentSearchUseCaseExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentSearchUseCaseExecuteCall) Do(f func(context.Context, dtos.PaginationInput, dtos.Filter) *dtos.Result) *MockIStudentSearchUseCaseExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentSearchUseCaseExecuteCall) DoAndReturn(f func(context.Context, dtos.PaginationInput, dtos.Filter) *dtos.Result) *MockIStudentSearchUseCaseExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/student_repository.go
Size: 11.24 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/repositories/student_repository.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/repositories/student_repository.go -destination=internal/domain/mocks/student_repository.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dtos "github.com/dmarins/student-api/internal/domain/dtos"
	entities "github.com/dmarins/student-api/internal/domain/entities"
	gomock "go.uber.org/mock/gomock"
)

// MockIStudentRepository is a mock of IStudentRepository interface.
type MockIStudentRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIStudentRepositoryMockRecorder
	isgomock struct{}
}

// MockIStudentRepositoryMockRecorder is the mock recorder for MockIStudentRepository.
type MockIStudentRepositoryMockRecorder struct {
	mock *MockIStudentRepository
}

// NewMockIStudentRepository creates a new mock instance.
func NewMockIStudentRepository(ctrl *gomock.Controller) *MockIStudentRepository {
	mock := &MockIStudentRepository{ctrl: ctrl}
	mock.recorder = &MockIStudentRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStudentRepository) EXPECT() *MockIStudentRepositoryMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockIStudentRepository) Add(ctx context.Context, student *entities.Student) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, student)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockIStudentRepositoryMockRecorder) Add(ctx, student any) *MockIStudentRepositoryAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIStudentRepository)(nil).Add), ctx, student)
	return &MockIStudentRepositoryAddCall{Call: call}
}

// MockIStudentRepositoryAddCall wrap *gomock.Call
type MockIStudentRepositoryAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositoryAddCall) Return(arg0 error) *MockIStudentRepositoryAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositoryAddCall) Do(f func(context.Context, *entities.Student) error) *MockIStudentRepositoryAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositoryAddCall) DoAndReturn(f func(context.Context, *entities.Student) error) *MockIStudentRepositoryAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Count mocks base method.
func (m *MockIStudentRepository) Count(ctx context.Context, filter dtos.Filter) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx, filter)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockIStudentRepositoryMockRecorder) Count(ctx, filter any) *MockIStudentRepositoryCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockIStudentRepository)(nil).Count), ctx, filter)
	return &MockIStudentRepositoryCountCall{Call: call}
}

// MockIStudentRepositoryCountCall wrap *gomock.Call
type MockIStudentRepositoryCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositoryCountCall) Return(arg0 int, arg1 error) *MockIStudentRepositoryCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositoryCountCall) Do(f func(context.Context, dtos.Filter) (int, error)) *MockIStudentRepositoryCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositoryCountCall) DoAndReturn(f func(context.Context, dtos.Filter) (int, error)) *MockIStudentRepositoryCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockIStudentRepository) Delete(ctx context.Context, studentId string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, studentId)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockIStudentRepositoryMockRecorder) Delete(ctx, studentId any) *MockIStudentRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockIStudentRepository)(nil).Delete), ctx, studentId)
	return &MockIStudentRepositoryDeleteCall{Call: call}
}

// MockIStudentRepositoryDeleteCall wrap *gomock.Call
type MockIStudentRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositoryDeleteCall) Return(arg0 error) *MockIStudentRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositoryDeleteCall) Do(f func(context.Context, string) error) *MockIStudentRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositoryDeleteCall) DoAndReturn(f func(context.Context, string) error) *MockIStudentRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExistsByName mocks base method.
func (m *MockIStudentRepository) ExistsByName(ctx context.Context, name string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsByName", ctx, name)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExistsByName indicates an expected call of ExistsByName.
func (mr *MockIStudentRepositoryMockRecorder) ExistsByName(ctx, name any) *MockIStudentRepositoryExistsByNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsByName", reflect.TypeOf((*MockIStudentRepository)(nil).ExistsByName), ctx, name)
	return &MockIStudentRepositoryExistsByNameCall{Call: call}
}

// MockIStudentRepositoryExistsByNameCall wrap *gomock.Call
type MockIStudentRepositoryExistsByNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositoryExistsByNameCall) Return(arg0 bool, arg1 error) *MockIStudentRepositoryExistsByNameCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositoryExistsByNameCall) Do(f func(context.Context, string) (bool, error)) *MockIStudentRepositoryExistsByNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositoryExistsByNameCall) DoAndReturn(f func(context.Context, string) (bool, error)) *MockIStudentRepositoryExistsByNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindById mocks base method.
func (m *MockIStudentRepository) FindById(ctx context.Context, studentId string) (*entities.Student, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindById", ctx, studentId)
	ret0, _ := ret[0].(*entities.Student)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindById indicates an expected call of FindById.
func (mr *MockIStudentRepositoryMockRecorder) FindById(ctx, studentId any) *MockIStudentRepositoryFindByIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindById", reflect.TypeOf((*MockIStudentRepository)(nil).FindById), ctx, studentId)
	return &MockIStudentRepositoryFindByIdCall{Call: call}
}

// MockIStudentRepositoryFindByIdCall wrap *gomock.Call
type MockIStudentRepositoryFindByIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositoryFindByIdCall) Return(arg0 *entities.Student, arg1 error) *MockIStudentRepositoryFindByIdCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositoryFindByIdCall) Do(f func(context.Context, string) (*entities.Student, error)) *MockIStudentRepositoryFindByIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositoryFindByIdCall) DoAndReturn(f func(context.Context, string) (*entities.Student, error)) *MockIStudentRepositoryFindByIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SearchBy mocks base method.
func (m *MockIStudentRepository) SearchBy(ctx context.Context, pagination dtos.PaginationInput, filter dtos.Filter) ([]*entities.Student, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchBy", ctx, pagination, filter)
	ret0, _ := ret[0].([]*entities.Student)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchBy indicates an expected call of SearchBy.
func (mr *MockIStudentRepositoryMockRecorder) SearchBy(ctx, pagination, filter any) *MockIStudentRepositorySearchByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchBy", reflect.TypeOf((*MockIStudentRepository)(nil).SearchBy), ctx, pagination, filter)
	return &MockIStudentRepositorySearchByCall{Call: call}
}

// MockIStudentRepositorySearchByCall wrap *gomock.Call
type MockIStudentRepositorySearchByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositorySearchByCall) Return(arg0 []*entities.Student, arg1 error) *MockIStudentRepositorySearchByCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositorySearchByCall) Do(f func(context.Context, dtos.PaginationInput, dtos.Filter) ([]*entities.Student, error)) *MockIStudentRepositorySearchByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositorySearchByCall) DoAndReturn(f func(context.Context, dtos.PaginationInput, dtos.Filter) ([]*entities.Student, error)) *MockIStudentRepositorySearchByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockIStudentRepository) Update(ctx context.Context, student *entities.Student) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, student)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockIStudentRepositoryMockRecorder) Update(ctx, student any) *MockIStudentRepositoryUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockIStudentRepository)(nil).Update), ctx, student)
	return &MockIStudentRepositoryUpdateCall{Call: call}
}

// MockIStudentRepositoryUpdateCall wrap *gomock.Call
type MockIStudentRepositoryUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentRepositoryUpdateCall) Return(arg0 error) *MockIStudentRepositoryUpdateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentRepositoryUpdateCall) Do(f func(context.Context, *entities.Student) error) *MockIStudentRepositoryUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentRepositoryUpdateCall) DoAndReturn(f func(context.Context, *entities.Student) error) *MockIStudentRepositoryUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/student_update.go
Size: 2.83 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/domain/usecases/student_update.go
//
// Generated by this command:
//
//	mockgen -source=internal/domain/usecases/student_update.go -destination=internal/domain/mocks/student_update.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	dtos "github.com/dmarins/student-api/internal/domain/dtos"
	gomock "go.uber.org/mock/gomock"
)

// MockIStudentUpdateUseCase is a mock of IStudentUpdateUseCase interface.
type MockIStudentUpdateUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIStudentUpdateUseCaseMockRecorder
	isgomock struct{}
}

// MockIStudentUpdateUseCaseMockRecorder is the mock recorder for MockIStudentUpdateUseCase.
type MockIStudentUpdateUseCaseMockRecorder struct {
	mock *MockIStudentUpdateUseCase
}

// NewMockIStudentUpdateUseCase creates a new mock instance.
func NewMockIStudentUpdateUseCase(ctrl *gomock.Controller) *MockIStudentUpdateUseCase {
	mock := &MockIStudentUpdateUseCase{ctrl: ctrl}
	mock.recorder = &MockIStudentUpdateUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStudentUpdateUseCase) EXPECT() *MockIStudentUpdateUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockIStudentUpdateUseCase) Execute(ctx context.Context, studentUpdateInput dtos.StudentUpdateInput) *dtos.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, studentUpdateInput)
	ret0, _ := ret[0].(*dtos.Result)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockIStudentUpdateUseCaseMockRecorder) Execute(ctx, studentUpdateInput any) *MockIStudentUpdateUseCaseExecuteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockIStudentUpdateUseCase)(nil).Execute), ctx, studentUpdateInput)
	return &MockIStudentUpdateUseCaseExecuteCall{Call: call}
}

// MockIStudentUpdateUseCaseExecuteCall wrap *gomock.Call
type MockIStudentUpdateUseCaseExecuteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIStudentUpdateUseCaseExecuteCall) Return(arg0 *dtos.Result) *MockIStudentUpdateUseCaseExecuteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIStudentUpdateUseCaseExecuteCall) Do(f func(context.Context, dtos.StudentUpdateInput) *dtos.Result) *MockIStudentUpdateUseCaseExecuteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIStudentUpdateUseCaseExecuteCall) DoAndReturn(f func(context.Context, dtos.StudentUpdateInput) *dtos.Result) *MockIStudentUpdateUseCaseExecuteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/mocks/tracer.go
Size: 6.55 kB
================================================================================

// Code generated by MockGen. DO NOT EDIT.
// Source: internal/infrastructure/tracer/tracer.go
//
// Generated by this command:
//
//	mockgen -source=internal/infrastructure/tracer/tracer.go -destination=internal/domain/mocks/tracer.go -typed=true -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	http "net/http"
	reflect "reflect"

	logger "github.com/dmarins/student-api/internal/infrastructure/logger"
	tracer "github.com/dmarins/student-api/internal/infrastructure/tracer"
	gomock "go.uber.org/mock/gomock"
)

// MockITracer is a mock of ITracer interface.
type MockITracer struct {
	ctrl     *gomock.Controller
	recorder *MockITracerMockRecorder
	isgomock struct{}
}

// MockITracerMockRecorder is the mock recorder for MockITracer.
type MockITracerMockRecorder struct {
	mock *MockITracer
}

// NewMockITracer creates a new mock instance.
func NewMockITracer(ctrl *gomock.Controller) *MockITracer {
	mock := &MockITracer{ctrl: ctrl}
	mock.recorder = &MockITracerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITracer) EXPECT() *MockITracerMockRecorder {
	return m.recorder
}

// AddAttributes mocks base method.
func (m *MockITracer) AddAttributes(span tracer.ISpan, name string, attributes tracer.Attributes) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddAttributes", span, name, attributes)
}

// AddAttributes indicates an expected call of AddAttributes.
func (mr *MockITracerMockRecorder) AddAttributes(span, name, attributes any) *MockITracerAddAttributesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAttributes", reflect.TypeOf((*MockITracer)(nil).AddAttributes), span, name, attributes)
	return &MockITracerAddAttributesCall{Call: call}
}

// MockITracerAddAttributesCall wrap *gomock.Call
type MockITracerAddAttributesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockITracerAddAttributesCall) Return() *MockITracerAddAttributesCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockITracerAddAttributesCall) Do(f func(tracer.ISpan, string, tracer.Attributes)) *MockITracerAddAttributesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockITracerAddAttributesCall) DoAndReturn(f func(tracer.ISpan, string, tracer.Attributes)) *MockITracerAddAttributesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewRootSpan mocks base method.
func (m *MockITracer) NewRootSpan(request *http.Request, spanName string) (tracer.ISpan, context.Context) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewRootSpan", request, spanName)
	ret0, _ := ret[0].(tracer.ISpan)
	ret1, _ := ret[1].(context.Context)
	return ret0, ret1
}

// NewRootSpan indicates an expected call of NewRootSpan.
func (mr *MockITracerMockRecorder) NewRootSpan(request, spanName any) *MockITracerNewRootSpanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewRootSpan", reflect.TypeOf((*MockITracer)(nil).NewRootSpan), request, spanName)
	return &MockITracerNewRootSpanCall{Call: call}
}

// MockITracerNewRootSpanCall wrap *gomock.Call
type MockITracerNewRootSpanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockITracerNewRootSpanCall) Return(arg0 tracer.ISpan, arg1 context.Context) *MockITracerNewRootSpanCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockITracerNewRootSpanCall) Do(f func(*http.Request, string) (tracer.ISpan, context.Context)) *MockITracerNewRootSpanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockITracerNewRootSpanCall) DoAndReturn(f func(*http.Request, string) (tracer.ISpan, context.Context)) *MockITracerNewRootSpanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewSpanContext mocks base method.
func (m *MockITracer) NewSpanContext(ctx context.Context, spanName string) (tracer.ISpan, context.Context) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewSpanContext", ctx, spanName)
	ret0, _ := ret[0].(tracer.ISpan)
	ret1, _ := ret[1].(context.Context)
	return ret0, ret1
}

// NewSpanContext indicates an expected call of NewSpanContext.
func (mr *MockITracerMockRecorder) NewSpanContext(ctx, spanName any) *MockITracerNewSpanContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewSpanContext", reflect.TypeOf((*MockITracer)(nil).NewSpanContext), ctx, spanName)
	return &MockITracerNewSpanContextCall{Call: call}
}

// MockITracerNewSpanContextCall wrap *gomock.Call
type MockITracerNewSpanContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockITracerNewSpanContextCall) Return(arg0 tracer.ISpan, arg1 context.Context) *MockITracerNewSpanContextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockITracerNewSpanContextCall) Do(f func(context.Context, string) (tracer.ISpan, context.Context)) *MockITracerNewSpanContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockITracerNewSpanContextCall) DoAndReturn(f func(context.Context, string) (tracer.ISpan, context.Context)) *MockITracerNewSpanContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Shutdown mocks base method.
func (m *MockITracer) Shutdown(ctx context.Context, logger logger.ILogger) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Shutdown", ctx, logger)
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockITracerMockRecorder) Shutdown(ctx, logger any) *MockITracerShutdownCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockITracer)(nil).Shutdown), ctx, logger)
	return &MockITracerShutdownCall{Call: call}
}

// MockITracerShutdownCall wrap *gomock.Call
type MockITracerShutdownCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockITracerShutdownCall) Return() *MockITracerShutdownCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockITracerShutdownCall) Do(f func(context.Context, logger.ILogger)) *MockITracerShutdownCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockITracerShutdownCall) DoAndReturn(f func(context.Context, logger.ILogger)) *MockITracerShutdownCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}


================================================================================
File: internal/domain/repositories/healthcheck_repository.go
Size: 133 B
================================================================================

package repositories

import (
	"context"
)

type IHealthCheckRepository interface {
	CheckDbConnection(ctx context.Context) error
}


================================================================================
File: internal/domain/repositories/student_repository.go
Size: 684 B
================================================================================

package repositories

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
)

type IStudentRepository interface {
	Add(ctx context.Context, student *entities.Student) error
	ExistsByName(ctx context.Context, name string) (bool, error)
	FindById(ctx context.Context, studentId string) (*entities.Student, error)
	Update(ctx context.Context, student *entities.Student) error
	Delete(ctx context.Context, studentId string) error
	SearchBy(ctx context.Context, pagination dtos.PaginationInput, filter dtos.Filter) ([]*entities.Student, error)
	Count(ctx context.Context, filter dtos.Filter) (int, error)
}


================================================================================
File: internal/domain/usecases/healthcheck.go
Size: 179 B
================================================================================

package usecases

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

type IHealthCheckUseCase interface {
	Execute(ctx context.Context) *dtos.Result
}


================================================================================
File: internal/domain/usecases/student_create.go
Size: 225 B
================================================================================

package usecases

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

type IStudentCreateUseCase interface {
	Execute(ctx context.Context, studentCreateInput dtos.StudentCreateInput) *dtos.Result
}


================================================================================
File: internal/domain/usecases/student_delete.go
Size: 199 B
================================================================================

package usecases

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

type IStudentDeleteUseCase interface {
	Execute(ctx context.Context, studentId string) *dtos.Result
}


================================================================================
File: internal/domain/usecases/student_read.go
Size: 335 B
================================================================================

package usecases

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

type IStudentReadUseCase interface {
	Execute(ctx context.Context, studentId string) *dtos.Result
}

type IStudentSearchUseCase interface {
	Execute(ctx context.Context, pagination dtos.PaginationInput, filter dtos.Filter) *dtos.Result
}


================================================================================
File: internal/domain/usecases/student_update.go
Size: 225 B
================================================================================

package usecases

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

type IStudentUpdateUseCase interface {
	Execute(ctx context.Context, studentUpdateInput dtos.StudentUpdateInput) *dtos.Result
}


================================================================================
File: internal/infrastructure/db/db.go
Size: 2.06 kB
================================================================================

package db

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	_ "github.com/lib/pq"
)

type (
	IDb interface {
		Close(ctx context.Context, logger logger.ILogger)
		ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
		QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
		QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	}

	Db struct {
		postgres *sql.DB
	}
)

func NewDatabase(ctx context.Context, logger logger.ILogger) IDb {
	host := env.ProvideDbHost()
	port := env.ProvideDbPort()

	dsn := fmt.
		Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
			host,
			port,
			env.ProvideDbUser(),
			env.ProvideDbPassword(),
			env.ProvideDbName(),
		)

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		logger.Fatal(ctx, "failed to open database", err)
		return nil
	}

	err = db.PingContext(ctx)
	if err != nil {
		logger.Fatal(ctx, "failed to verify connection to database", err)
		return nil
	}

	logger.Info(ctx, "db connected", "address", fmt.Sprintf("%s:%s", host, port))

	return &Db{
		postgres: db,
	}
}

func NewIntegrationTestDatabase(db *sql.DB) IDb {
	return &Db{
		postgres: db,
	}
}

func (d *Db) Close(ctx context.Context, logger logger.ILogger) {
	if d.postgres != nil {
		err := d.postgres.Close()
		if err != nil {
			logger.Error(ctx, "failed to close database connection", err)
			return
		}
	}

	logger.Info(ctx, "database connection closed successfully")
}

func (d *Db) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	return d.postgres.ExecContext(ctx, query, args...)
}

func (d *Db) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	return d.postgres.QueryRowContext(ctx, query, args...)
}

func (d *Db) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	return d.postgres.QueryContext(ctx, query, args...)
}


================================================================================
File: internal/infrastructure/di/di.go
Size: 411 B
================================================================================

package di

import (
	"context"

	"go.uber.org/fx"
)

func StartCompositionRoot(options ...fx.Option) *fx.App {
	baseOptions := []fx.Option{
		fx.Provide(
			func() context.Context { return context.Background() },
		),
		registerHooks(),
		infrastructureModule(),
		repositoriesModule(),
		useCasesModule(),
		handlersModule(),
	}

	allOptions := append(baseOptions, options...)
	return fx.New(allOptions...)
}


================================================================================
File: internal/infrastructure/di/handlers_module.go
Size: 1.38 kB
================================================================================

package di

import (
	"github.com/dmarins/student-api/internal/adapters/handlers"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"go.uber.org/fx"
)

func handlersModule() fx.Option {
	return fx.Module("handlers",
		healthCheckHandler(),
		studentHandler(),
		fx.Invoke(
			handlers.RegisterHealthCheckRoute,
			handlers.RegisterStudentRoutes,
		),
	)
}

func healthCheckHandler() fx.Option {
	return fx.Provide(
		handlers.NewHealthCheckHandler,
	)
}

func provideStudentHandler(tracer tracer.ITracer,
	logger logger.ILogger,
	studentCreateUseCase usecases.IStudentCreateUseCase,
	studentReadUseCase usecases.IStudentReadUseCase,
	studentUpdateUseCase usecases.IStudentUpdateUseCase,
	studentDeleteUseCase usecases.IStudentDeleteUseCase,
	studentSearchUseCase usecases.IStudentSearchUseCase) *handlers.StudentHandler {
	return handlers.NewStudentHandler(tracer,
		logger,
		studentCreateUseCase,
		studentReadUseCase,
		studentUpdateUseCase,
		studentDeleteUseCase,
		studentSearchUseCase)
}

func studentHandler() fx.Option {
	return fx.Provide(
		fx.Annotate(provideStudentHandler,
			fx.ParamTags(``, ``, `name:"studentCreateWithNameCheck"`, ``, `name:"studentUpdateWithFindById"`, `name:"studentDeleteWithFindById"`, ``),
		),
	)
}


================================================================================
File: internal/infrastructure/di/hooks_module.go
Size: 791 B
================================================================================

package di

import (
	"context"

	"github.com/dmarins/student-api/internal/infrastructure/db"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/server"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"go.uber.org/fx"
)

func registerHooks() fx.Option {
	return fx.Invoke(func(lc fx.Lifecycle, tracer tracer.ITracer, logger logger.ILogger, db db.IDb, server server.IServer) {
		lc.Append(fx.Hook{
			OnStart: func(ctx context.Context) error {
				go server.ListenAndServe(ctx, logger)
				return nil
			},
			OnStop: func(ctx context.Context) error {
				logger.Sync(ctx)
				tracer.Shutdown(ctx, logger)
				db.Close(ctx, logger)
				return server.GracefulShutdownServer(ctx, logger)
			},
		})
	})
}


================================================================================
File: internal/infrastructure/di/infrastructure_module.go
Size: 636 B
================================================================================

package di

import (
	"github.com/dmarins/student-api/internal/infrastructure/db"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/server"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"go.uber.org/fx"
)

func infrastructureModule() fx.Option {
	return fx.Module("infrastructure",
		fx.Provide(
			fx.Annotate(logger.NewLogger, fx.As(new(logger.ILogger))),
			fx.Annotate(tracer.NewTracer, fx.As(new(tracer.ITracer))),
			fx.Annotate(db.NewDatabase, fx.As(new(db.IDb))),
			fx.Annotate(server.NewServer, fx.As(new(server.IServer))),
		),
	)
}


================================================================================
File: internal/infrastructure/di/repositories_module.go
Size: 500 B
================================================================================

package di

import (
	"github.com/dmarins/student-api/internal/adapters/repositories"
	domain_repositories "github.com/dmarins/student-api/internal/domain/repositories"
	"go.uber.org/fx"
)

func repositoriesModule() fx.Option {
	return fx.Module("repositories",
		fx.Provide(
			fx.Annotate(repositories.NewHealthCheckRepository, fx.As(new(domain_repositories.IHealthCheckRepository))),
			fx.Annotate(repositories.NewStudentRepository, fx.As(new(domain_repositories.IStudentRepository))),
		),
	)
}


================================================================================
File: internal/infrastructure/di/usecases_module.go
Size: 2.77 kB
================================================================================

package di

import (
	domain_usecases "github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/usecases/healthcheck"
	"github.com/dmarins/student-api/internal/usecases/student/create"
	"github.com/dmarins/student-api/internal/usecases/student/delete"
	"github.com/dmarins/student-api/internal/usecases/student/read"
	"github.com/dmarins/student-api/internal/usecases/student/update"
	"go.uber.org/fx"
)

func useCasesModule() fx.Option {
	return fx.Module("usecases",
		healthCheckUseCase(),
		createStudentUseCase(),
		readStudentUseCaseModule(),
		updateStudentUseCase(),
		deleteStudentUseCase(),
		searchStudentUseCaseModule(),
	)
}

func healthCheckUseCase() fx.Option {
	return fx.Provide(
		fx.Annotate(healthcheck.NewHealthCheck, fx.As(new(domain_usecases.IHealthCheckUseCase))),
	)
}

func createStudentUseCase() fx.Option {
	return fx.Provide(
		fx.Annotate(create.NewStudentCreateWithPersistence, fx.ResultTags(`name:"studentCreateWithPersistence"`),
			fx.As(new(domain_usecases.IStudentCreateUseCase))),
		fx.Annotate(create.NewStudentCreateWithNameCheck, fx.ParamTags(``, ``, ``, `name:"studentCreateWithPersistence"`),
			fx.ResultTags(`name:"studentCreateWithNameCheck"`), fx.As(new(domain_usecases.IStudentCreateUseCase)),
		),
	)
}

func readStudentUseCaseModule() fx.Option {
	return fx.Provide(
		fx.Annotate(read.NewStudentReadWithFindById, fx.As(new(domain_usecases.IStudentReadUseCase))),
	)
}

func updateStudentUseCase() fx.Option {
	return fx.Provide(
		fx.Annotate(update.NewStudentUpdateWithPersistence, fx.ResultTags(`name:"studentUpdateWithPersistence"`),
			fx.As(new(domain_usecases.IStudentUpdateUseCase))),
		fx.Annotate(update.NewStudentUpdateWithNameCheck, fx.ParamTags(``, ``, ``, `name:"studentUpdateWithPersistence"`),
			fx.ResultTags(`name:"studentUpdateWithNameCheck"`), fx.As(new(domain_usecases.IStudentUpdateUseCase))),
		fx.Annotate(update.NewStudentUpdateWithFindById, fx.ParamTags(``, ``, ``, `name:"studentUpdateWithNameCheck"`),
			fx.ResultTags(`name:"studentUpdateWithFindById"`), fx.As(new(domain_usecases.IStudentUpdateUseCase)),
		),
	)
}

func deleteStudentUseCase() fx.Option {
	return fx.Provide(
		fx.Annotate(delete.NewStudentDeleteWithPersistence, fx.ResultTags(`name:"studentDeleteWithPersistence"`),
			fx.As(new(domain_usecases.IStudentDeleteUseCase))),
		fx.Annotate(delete.NewStudentDeleteWithFindById, fx.ParamTags(``, ``, ``, `name:"studentDeleteWithPersistence"`),
			fx.ResultTags(`name:"studentDeleteWithFindById"`), fx.As(new(domain_usecases.IStudentDeleteUseCase)),
		),
	)
}

func searchStudentUseCaseModule() fx.Option {
	return fx.Provide(
		fx.Annotate(read.NewStudentSearchWithSearchBy, fx.As(new(domain_usecases.IStudentSearchUseCase))),
	)
}


================================================================================
File: internal/infrastructure/env/env.go
Size: 2.23 kB
================================================================================

package env

import (
	"log"
	"os"
	"path/filepath"
	"sync"

	"github.com/joho/godotenv"
)

var (
	once sync.Once
)

func LoadEnvironmentVariables() {
	var envFile string

	rootDir, err := findRootDir()
	if err != nil {
		log.Fatalf("failed to find the root directory: %v", err)
	}

	once.Do(func() {
		env := ProvideAppEnv()
		if env == "local" || env == "test" {
			envFile = filepath.Join(rootDir, ".env.local")
		} else {
			envFile = filepath.Join(rootDir, ".env")
		}

		err := godotenv.Load(envFile)
		if err != nil {
			log.Fatalf("failed to load environments variables, env: %s, env_file: %s", env, envFile)
		}
	})
}

func findRootDir() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, ".env")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}

		dir = parent
	}

	return "", os.ErrNotExist
}

func getEnvironmentVariable(key string) string {
	return os.Getenv(key)
}

func ProvideAppEnv() string {
	return getEnvironmentVariable("APP_ENV")
}

func ProvideAppName() string {
	return getEnvironmentVariable("APP_NAME")
}

func ProvideAppHost() string {
	return getEnvironmentVariable("APP_HOST")
}

func ProvideAppPort() string {
	return getEnvironmentVariable("APP_PORT")
}

func ProvideAppGracefulShutdownTimeoutInSeconds() string {
	return getEnvironmentVariable("APP_GRACEFUL_SHUTDOWN_TIMEOUT")
}

func ProvideTenantHeaderName() string {
	return getEnvironmentVariable("HEADER_TENANT")
}

func ProvideCidHeaderName() string {
	return getEnvironmentVariable("HEADER_CID")
}

func ProvideRequestContextName() string {
	return getEnvironmentVariable("REQUEST_CONTEXT")
}

func ProvideRequestTimeoutInSeconds() string {
	return getEnvironmentVariable("REQUEST_TIMEOUT")
}

func ProvideDbHost() string {
	return getEnvironmentVariable("POSTGRES_HOST")
}

func ProvideDbPort() string {
	return getEnvironmentVariable("POSTGRES_PORT")
}

func ProvideDbUser() string {
	return getEnvironmentVariable("POSTGRES_USER")
}

func ProvideDbPassword() string {
	return getEnvironmentVariable("POSTGRES_PASSWORD")
}

func ProvideDbName() string {
	return getEnvironmentVariable("POSTGRES_DB")
}


================================================================================
File: internal/infrastructure/logger/logger.go
Size: 2.77 kB
================================================================================

package logger

import (
	"context"
	"fmt"
	"strings"

	"github.com/dmarins/student-api/internal/infrastructure/env"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type (
	ILogger interface {
		Debug(ctx context.Context, msg string, fields ...string)
		Info(ctx context.Context, msg string, fields ...string)
		Error(ctx context.Context, msg string, err error, fields ...string)
		Fatal(ctx context.Context, msg string, err error, fields ...string)
		Warn(ctx context.Context, msg string, fields ...string)
		Sync(ctx context.Context)
	}

	Logger struct {
		zapLogger *zap.Logger
	}
)

func NewLogger() ILogger {
	config := zap.NewProductionConfig()

	if env.ProvideAppEnv() == "local" {
		config.Level = zap.NewAtomicLevelAt(zapcore.DebugLevel)
	}

	config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
	config.EncoderConfig.TimeKey = "timestamp"
	config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

	config.Encoding = "console"
	config.OutputPaths = []string{"stderr"}
	config.ErrorOutputPaths = []string{"stderr"}

	zapLogger, _ := config.Build(zap.AddCallerSkip(1))

	return &Logger{
		zapLogger: zapLogger,
	}
}

func messagePattern(msg string) string {
	return fmt.Sprintf("%s.", strings.ToLower(msg))
}

func convertStringFields(extraFields []string) []zap.Field {
	if len(extraFields)%2 != 0 {
		return nil
	}

	zapFields := make([]zap.Field, 0, len(extraFields)/2)
	for i := 0; i < len(extraFields); i += 2 {
		zapFields = append(zapFields, zap.String(extraFields[i], extraFields[i+1]))
	}

	return zapFields
}

func (l *Logger) Debug(ctx context.Context, msg string, fields ...string) {
	zapFields := convertStringFields(fields)

	l.zapLogger.Debug(messagePattern(msg), zapFields...)
}

func (l *Logger) Info(ctx context.Context, msg string, fields ...string) {
	zapFields := convertStringFields(fields)

	l.zapLogger.Info(messagePattern(msg), zapFields...)
}

func (l *Logger) Error(ctx context.Context, msg string, err error, fields ...string) {
	zapFields := convertStringFields(fields)
	zapFields = append(zapFields, zap.Error(err))

	l.zapLogger.Error(messagePattern(msg), zapFields...)
}

func (l *Logger) Fatal(ctx context.Context, msg string, err error, fields ...string) {
	zapFields := convertStringFields(fields)
	zapFields = append(zapFields, zap.Error(err))

	l.zapLogger.Fatal(messagePattern(msg), zapFields...)
}

func (l *Logger) Warn(ctx context.Context, msg string, fields ...string) {
	zapFields := convertStringFields(fields)

	l.zapLogger.Warn(messagePattern(msg), zapFields...)
}

func (l *Logger) Sync(ctx context.Context) {
	if l.zapLogger != nil {
		err := l.zapLogger.Sync()
		if err != nil {
			l.Error(ctx, "failed to sync logger", err)
			return
		}
	}

	l.Info(ctx, "Logger sync completed successfully")
}


================================================================================
File: internal/infrastructure/server/middlewares/cors.go
Size: 608 B
================================================================================

package middlewares

import (
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func CORS() echo.MiddlewareFunc {
	allowedMethods := []string{
		echo.POST,
		echo.GET,
		echo.PUT,
		echo.PATCH,
		echo.OPTIONS,
	}

	allowedHeaders := []string{
		echo.HeaderOrigin,
		echo.HeaderContentType,
		echo.HeaderAccept,
		echo.HeaderAuthorization,
	}

	allowedOrigins := []string{"*"}

	return middleware.CORSWithConfig(
		middleware.CORSConfig{
			AllowMethods:     allowedMethods,
			AllowOrigins:     allowedOrigins,
			AllowHeaders:     allowedHeaders,
			AllowCredentials: true,
		})
}


================================================================================
File: internal/infrastructure/server/middlewares/recover.go
Size: 966 B
================================================================================

package middlewares

import (
	"fmt"
	"net/http"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/labstack/echo/v4"
)

func Recover(logger logger.ILogger) echo.MiddlewareFunc {
	headerCidKey := env.ProvideCidHeaderName()

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			cid := c.Request().Header.Get(headerCidKey)
			ctx := c.Request().Context()

			defer func() {
				if r := recover(); r != nil {
					var err error
					switch r := r.(type) {
					case string:
						err = fmt.Errorf(r)
					case error:
						err = r
					default:
						err = fmt.Errorf("unknown panic: %v", r)
					}

					logger.Error(ctx, "panic recovered", err, "cid", cid)
					c.JSON(http.StatusInternalServerError, dtos.NewInternalServerErrorResult())
				}
			}()

			return next(c)
		}
	}
}


================================================================================
File: internal/infrastructure/server/middlewares/request.go
Size: 1.6 kB
================================================================================

package middlewares

import (
	"context"
	"net/http"
	"strings"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/uuid"
	"github.com/labstack/echo/v4"
)

var agnosticRoutes []string = []string{"/health", "/swagger"}

func isAgnosticRoute(path string) bool {
	for _, agnosticRoute := range agnosticRoutes {
		if strings.Contains(path, agnosticRoute) {
			return true
		}
	}

	return false
}

func RequestContext(logger logger.ILogger) echo.MiddlewareFunc {
	headerCidKey := env.ProvideCidHeaderName()
	headerTenantKey := env.ProvideTenantHeaderName()
	requestContextKey := env.ProvideRequestContextName()

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			ctx := c.Request().Context()
			path := c.Request().URL.Path

			if isAgnosticRoute(path) {
				return next(c)
			}

			cid := c.Request().Header.Get(headerCidKey)
			if cid == "" {
				cid = uuid.NewId()
				c.Request().Header.Set(headerCidKey, cid)
			}

			tenant := c.Request().Header.Get(headerTenantKey)
			if tenant == "" {
				logger.Warn(ctx, "the x-tenant header was not provided", "cid", cid)
				return c.JSON(http.StatusBadRequest, dtos.NewBadRequestResult())
			}

			rctx := dtos.RequestContext{
				TenantId: tenant,
				Cid:      cid,
			}

			ctxChanged := context.WithValue(ctx, requestContextKey, rctx)
			c.SetRequest(c.Request().WithContext(ctxChanged))

			return next(c)
		}
	}
}


================================================================================
File: internal/infrastructure/server/middlewares/timeout.go
Size: 1.31 kB
================================================================================

package middlewares

import (
	"context"
	"net/http"
	"time"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/labstack/echo/v4"
)

func Timeout(logger logger.ILogger) echo.MiddlewareFunc {
	ctx := context.Background()

	duration, err := time.ParseDuration(env.ProvideRequestTimeoutInSeconds())
	if err != nil {
		logger.Error(ctx, "could not parse REQUEST_TIMEOUT", err)

		duration = time.Second * 30
		logger.Warn(ctx, "using default REQUEST_TIMEOUT of 30s")
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			headerCidKey := env.ProvideCidHeaderName()
			cid := c.Request().Header.Get(headerCidKey)

			ctx, cancel := context.WithTimeout(c.Request().Context(), duration)
			defer cancel()

			c.SetRequest(c.Request().WithContext(ctx))

			done := make(chan error, 1)

			go func() {
				done <- next(c)
			}()

			select {
			case err := <-done:
				return err
			case <-ctx.Done():
				if ctx.Err() == context.DeadlineExceeded {
					logger.Error(ctx, "request timeout", err, "cid", cid)
					return c.JSON(http.StatusGatewayTimeout, dtos.NewGatewayTimeoutErrorResult())
				}

				return nil
			}
		}
	}
}


================================================================================
File: internal/infrastructure/server/server.go
Size: 2.14 kB
================================================================================

package server

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/server/middlewares"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"
)

type (
	IServer interface {
		GetEcho() *echo.Echo
		ListenAndServe(ctx context.Context, logger logger.ILogger)
		GracefulShutdownServer(ctx context.Context, logger logger.ILogger) error
	}

	Server struct {
		echo *echo.Echo
	}
)

func NewServer(logger logger.ILogger) IServer {
	e := echo.New()

	e.Use(middlewares.CORS())
	e.Use(middleware.Logger())
	e.Use(middlewares.RequestContext(logger))
	e.Use(middlewares.Timeout(logger))
	e.Use(middlewares.Recover(logger))

	e.GET("/swagger/*", echoSwagger.WrapHandler)

	e.Server.Addr = fmt.Sprintf("%s:%s", env.ProvideAppHost(), env.ProvideAppPort())

	e.Validator = NewValidator()

	return &Server{
		echo: e,
	}
}

func (s *Server) GetEcho() *echo.Echo {
	return s.echo
}

func (s *Server) ListenAndServe(ctx context.Context, logger logger.ILogger) {
	logger.Info(ctx, "HTTP server started", "address", s.echo.Server.Addr)

	s.echo.Server.ListenAndServe()
}

func (s *Server) GracefulShutdownServer(ctx context.Context, logger logger.ILogger) error {
	if env.ProvideAppEnv() == "test" {
		return nil
	}

	duration, err := time.ParseDuration(env.ProvideAppGracefulShutdownTimeoutInSeconds())
	if err != nil {
		logger.Error(ctx, "could not parse APP_GRACEFUL_SHUTDOWN_TIMEOUT", err)

		duration = time.Second * 5
		logger.Warn(ctx, "using default APP_GRACEFUL_SHUTDOWN_TIMEOUT of 5s")
	}

	shutdownCtx, cancel := context.WithTimeout(ctx, duration)
	defer cancel()

	err = s.echo.Shutdown(shutdownCtx)
	if err != nil {
		logger.Error(shutdownCtx, "failed to gracefull server shutdown", err)
		return err
	}

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	logger.Info(ctx, "Graceful server shutdown completed successfully")

	return nil
}


================================================================================
File: internal/infrastructure/server/validator.go
Size: 910 B
================================================================================

package server

import (
	"net/http"
	"reflect"
	"strings"

	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
)

type CustomValidator struct {
	validate *validator.Validate
}

func NewValidator() *CustomValidator {
	validate := validator.New()
	validate.RegisterTagNameFunc(func(fld reflect.StructField) string {
		name := strings.Split(fld.Tag.Get("json"), ",")[0]
		if name == "-" {
			return ""
		}

		return name
	})

	return &CustomValidator{validate: validate}
}

func (cv *CustomValidator) Validate(i interface{}) error {
	if err := cv.validate.Struct(i); err != nil {
		validationErrors := err.(validator.ValidationErrors)
		var errorMessages []string

		for _, ve := range validationErrors {
			errorMessages = append(errorMessages, ve.Field()+" is invalid: "+ve.Tag())
		}

		return echo.NewHTTPError(http.StatusBadRequest, strings.Join(errorMessages, ", "))
	}

	return nil
}


================================================================================
File: internal/infrastructure/tests/e2e_tests.go
Size: 1.13 kB
================================================================================

package tests

import (
	"context"
	"log"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/infrastructure/di"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/server"
	"github.com/gavv/httpexpect/v2"
	"go.uber.org/fx"
)

type E2eTestsBuilder struct {
	Ctx        context.Context
	App        *fx.App
	AppServer  server.IServer
	TestServer *httptest.Server
}

func NewE2eTestsBuilder() *E2eTestsBuilder {
	os.Setenv("APP_ENV", "test")
	env.LoadEnvironmentVariables()

	return &E2eTestsBuilder{
		Ctx: context.Background(),
	}
}

func (b *E2eTestsBuilder) StartCompositionRoot() *E2eTestsBuilder {
	app := di.StartCompositionRoot(fx.Populate(&b.AppServer))

	if err := app.Start(b.Ctx); err != nil {
		log.Fatalf("failed to initialize FX: %v", err)
	}

	b.App = app

	return b
}

func (b *E2eTestsBuilder) StartTestServer() *E2eTestsBuilder {
	b.TestServer = httptest.NewServer(b.AppServer.GetEcho())

	return b
}

func (b *E2eTestsBuilder) Build(t *testing.T) *httpexpect.Expect {
	return httpexpect.Default(t, b.TestServer.URL)
}


================================================================================
File: internal/infrastructure/tests/integration_tests.go
Size: 3.82 kB
================================================================================

package tests

import (
	"context"
	"database/sql"
	"log"
	"path/filepath"
	"time"

	"github.com/dmarins/student-api/internal/adapters/repositories"
	domain_repositories "github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/infrastructure/db"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

type IntegrationTestsBuilder struct {
	Ctx         context.Context
	PgContainer *postgres.PostgresContainer
	DbConn      *sql.DB
	postgresDb  db.IDb
	logger      logger.ILogger
	tracer      tracer.ITracer
}

func NewIntegrationTestsBuilder() *IntegrationTestsBuilder {
	ctx := context.Background()

	pgContainer, err := postgres.Run(
		ctx,
		"docker.io/postgres:16.4-alpine3.20",
		postgres.WithDatabase("students"),
		postgres.WithUsername("testuser"),
		postgres.WithPassword("testpass"),
		postgres.WithInitScripts(filepath.Join("../../../migrations", "000001_create_students_table.up.sql")),
		postgres.WithInitScripts(filepath.Join("../../../migrations", "000002_insert_students.up.sql")),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(5*time.Second),
		),
	)
	if err != nil {
		log.Fatalf("Failed to start postgres container: %s", err)
	}

	dsn, err := pgContainer.ConnectionString(ctx, "sslmode=disable", "application_name=student-api-integration-tests")
	if err != nil {
		log.Fatalf("Failed to get postgres container port: %s", err)
	}

	dbConn, err := sql.Open("postgres", dsn)
	if err != nil {
		log.Fatalf("Failed to connect to postgres container: %s", err)
	}

	err = dbConn.Ping()
	if err != nil {
		log.Fatalf("Failed to ping postgres container: %s", err)
	}

	postgresDb := db.NewIntegrationTestDatabase(dbConn)

	return &IntegrationTestsBuilder{
		Ctx:         ctx,
		PgContainer: pgContainer,
		DbConn:      dbConn,
		postgresDb:  postgresDb,
	}
}

func NewFailedIntegrationTestsBuilder() *IntegrationTestsBuilder {
	ctx := context.Background()

	pgContainer, err := postgres.Run(
		ctx,
		"docker.io/postgres:16.4-alpine3.20",
		postgres.WithDatabase("students"),
		postgres.WithUsername("testuser"),
		postgres.WithPassword("testpass"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(5*time.Second),
		),
	)
	if err != nil {
		log.Fatalf("Failed to start postgres container: %s", err)
	}

	dsn, err := pgContainer.ConnectionString(ctx, "sslmode=enabled", "application_name=student-api-integration-tests")
	if err != nil {
		log.Fatalf("Failed to get postgres container port: %s", err)
	}

	dbConn, err := sql.Open("postgres", dsn)
	if err != nil {
		log.Fatalf("Failed to connect to postgres container: %s", err)
	}

	postgresDb := db.NewIntegrationTestDatabase(dbConn)

	return &IntegrationTestsBuilder{
		Ctx:         ctx,
		PgContainer: pgContainer,
		DbConn:      dbConn,
		postgresDb:  postgresDb,
	}
}

func (b *IntegrationTestsBuilder) WithLogger() *IntegrationTestsBuilder {
	b.logger = logger.NewLogger()

	return b
}

func (b *IntegrationTestsBuilder) WithTracer() *IntegrationTestsBuilder {
	b.tracer = tracer.NewTracer(b.Ctx, b.logger)

	return b
}

func (b *IntegrationTestsBuilder) BuildStudentRepository() domain_repositories.IStudentRepository {
	return repositories.NewStudentRepository(b.tracer, b.postgresDb)
}

func (b *IntegrationTestsBuilder) BuildHealthCheckRepository() domain_repositories.IHealthCheckRepository {
	return repositories.NewHealthCheckRepository(b.tracer, b.postgresDb)
}


================================================================================
File: internal/infrastructure/tests/unit_tests.go
Size: 5.46 kB
================================================================================

package tests

import (
	"context"
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/mocks"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/usecases/healthcheck"
	"github.com/dmarins/student-api/internal/usecases/student/create"
	"github.com/dmarins/student-api/internal/usecases/student/delete"
	"github.com/dmarins/student-api/internal/usecases/student/read"
	"github.com/dmarins/student-api/internal/usecases/student/update"
	"go.uber.org/mock/gomock"
)

type UnitTestsBuilder struct {
	Ctx                       context.Context
	Ctrl                      *gomock.Controller
	TracerMock                *mocks.MockITracer
	SpanMock                  *mocks.MockISpan
	LoggerMock                *mocks.MockILogger
	StudentRepositoryMock     *mocks.MockIStudentRepository
	HealthCheckRepositoryMock *mocks.MockIHealthCheckRepository
	StudentCreateUseCaseMock  *mocks.MockIStudentCreateUseCase
	StudentUpdateUseCaseMock  *mocks.MockIStudentUpdateUseCase
	StudentDeleteUseCaseMock  *mocks.MockIStudentDeleteUseCase
}

func NewUnitTestsBuilder(t *testing.T) *UnitTestsBuilder {
	ctrl := gomock.NewController(t)
	loggerMock := mocks.NewMockILogger(ctrl)
	tracerMock := mocks.NewMockITracer(ctrl)
	spanMock := mocks.NewMockISpan(ctrl)
	studentRepositoryMock := mocks.NewMockIStudentRepository(ctrl)
	healthCheckRepositoryMock := mocks.NewMockIHealthCheckRepository(ctrl)
	studentCreateUseCaseMock := mocks.NewMockIStudentCreateUseCase(ctrl)
	studentUpdateUseCaseMock := mocks.NewMockIStudentUpdateUseCase(ctrl)
	studentDeleteUseCaseMock := mocks.NewMockIStudentDeleteUseCase(ctrl)

	return &UnitTestsBuilder{
		Ctrl:                      ctrl,
		LoggerMock:                loggerMock,
		TracerMock:                tracerMock,
		SpanMock:                  spanMock,
		StudentRepositoryMock:     studentRepositoryMock,
		HealthCheckRepositoryMock: healthCheckRepositoryMock,
		StudentCreateUseCaseMock:  studentCreateUseCaseMock,
		StudentUpdateUseCaseMock:  studentUpdateUseCaseMock,
		StudentDeleteUseCaseMock:  studentDeleteUseCaseMock,
	}
}

func (b *UnitTestsBuilder) WithValidCtx() *UnitTestsBuilder {
	requestContext := dtos.RequestContext{
		TenantId: "x-tenant",
		Cid:      "cid",
	}

	b.Ctx = context.WithValue(
		context.Background(),
		env.ProvideRequestContextName(),
		requestContext,
	)

	return b
}

func (b *UnitTestsBuilder) SettingTracerBehavior(spanName string) *UnitTestsBuilder {
	b.TracerMock.
		EXPECT().
		NewSpanContext(b.Ctx, spanName).
		Return(b.SpanMock, b.Ctx).
		Times(1)

	b.SpanMock.
		EXPECT().
		End().
		Times(1)

	b.TracerMock.
		EXPECT().
		AddAttributes(b.SpanMock, spanName, gomock.Any()).
		AnyTimes()

	return b
}

func (b *UnitTestsBuilder) SettingLoggerDebugBehavior(debugMessage string, fields ...any) *UnitTestsBuilder {
	b.LoggerMock.
		EXPECT().
		Debug(b.Ctx, debugMessage, fields...)

	return b
}

func (b *UnitTestsBuilder) SettingLoggerWarnBehavior(debugMessage string, fields ...any) *UnitTestsBuilder {
	b.LoggerMock.
		EXPECT().
		Warn(b.Ctx, debugMessage, fields...)

	return b
}

func (b *UnitTestsBuilder) SettingLoggerErrorBehavior(debugMessage string, err error, fields ...any) *UnitTestsBuilder {
	b.LoggerMock.
		EXPECT().
		Error(b.Ctx, debugMessage, err, fields...)

	return b
}

func (b *UnitTestsBuilder) BuildHealthCheckUseCase() usecases.IHealthCheckUseCase {
	return healthcheck.NewHealthCheck(b.TracerMock, b.LoggerMock, b.HealthCheckRepositoryMock)
}

func (b *UnitTestsBuilder) BuildStudentCreateWithNameCheck() usecases.IStudentCreateUseCase {
	return create.NewStudentCreateWithNameCheck(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock, b.StudentCreateUseCaseMock)
}

func (b *UnitTestsBuilder) BuildStudentCreateWithPersistence() usecases.IStudentCreateUseCase {
	return create.NewStudentCreateWithPersistence(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock)
}

func (b *UnitTestsBuilder) BuildStudentReadWithFindByID() usecases.IStudentReadUseCase {
	return read.NewStudentReadWithFindById(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock)
}

func (b *UnitTestsBuilder) BuildStudentUpdateWithNameCheck() usecases.IStudentUpdateUseCase {
	return update.NewStudentUpdateWithNameCheck(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock, b.StudentUpdateUseCaseMock)
}

func (b *UnitTestsBuilder) BuildStudentUpdateWithFindById() usecases.IStudentUpdateUseCase {
	return update.NewStudentUpdateWithFindById(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock, b.StudentUpdateUseCaseMock)
}

func (b *UnitTestsBuilder) BuildStudentUpdateWithPersistence() usecases.IStudentUpdateUseCase {
	return update.NewStudentUpdateWithPersistence(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock)
}

func (b *UnitTestsBuilder) BuildStudentDeleteWithFindById() usecases.IStudentDeleteUseCase {
	return delete.NewStudentDeleteWithFindById(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock, b.StudentDeleteUseCaseMock)
}

func (b *UnitTestsBuilder) BuildStudentDeleteWithPersistence() usecases.IStudentDeleteUseCase {
	return delete.NewStudentDeleteWithPersistence(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock)
}

func (b *UnitTestsBuilder) BuildStudentSearchWithSearchBy() usecases.IStudentSearchUseCase {
	return read.NewStudentSearchWithSearchBy(b.TracerMock, b.LoggerMock, b.StudentRepositoryMock)
}


================================================================================
File: internal/infrastructure/tests/utils.go
Size: 68 B
================================================================================

package tests

func ToPointer[T any](value T) *T {
	return &value
}


================================================================================
File: internal/infrastructure/tracer/span_names.go
Size: 1.62 kB
================================================================================

package tracer

const (
	HealthCheckHandlerGet = "HealthCheckHandler:Get"
	StudentHandlerCreate  = "StudentHandler:Create"
	StudentHandlerRead    = "StudentHandler:Read"
	StudentHandlerUpdate  = "StudentHandler:Update"
	StudentHandlerDelete  = "StudentHandler:Delete"
	StudentHandlerSearch  = "StudentHandler:Search"

	HealthCheckExecute                     = "HealthCheck:Execute"
	StudentCreateUseCasePersistenceExecute = "StudentCreateUseCasePersistence:Execute"
	StudentCreateUseCaseValidationsExecute = "StudentCreateUseCaseValidations:Execute"
	StudentReadUseCaseFindByIdExecute      = "StudentReadUseCaseFindById:Execute"
	StudentUpdateUseCasePersistenceExecute = "StudentUpdateUseCasePersistence:Execute"
	StudentUpdateUseCaseValidationsExecute = "StudentUpdateUseCaseValidations:Execute"
	StudentDeleteUseCaseFindByIdExecute    = "StudentDeleteUseCaseFindById:Execute"
	StudentDeleteUseCasePersistenceExecute = "StudentDeleteUseCasePersistence:Execute"
	StudentSearchUseCaseSearchByExecute    = "StudentSearchUseCaseSearchBy:Execute"

	HealthCheckRepositoryCheckDbConnection = "HealthCheckRepository:CheckDbConnection"
	StudentRepositoryAdd                   = "StudentRepository:Add"
	StudentRepositoryExistsByName          = "StudentRepository:ExistsByName"
	StudentRepositoryFindById              = "StudentRepository:FindById"
	StudentRepositoryUpdate                = "StudentRepository:Update"
	StudentRepositoryDelete                = "StudentRepository:Delete"
	StudentRepositorySearchBy              = "StudentRepository:SearchBy"
	StudentRepositoryCount                 = "StudentRepository:Count"
)


================================================================================
File: internal/infrastructure/tracer/span_wrapper.go
Size: 92 B
================================================================================

package tracer

type ISpan interface {
	End()
	AddEvent(name string, opts ...interface{})
}


================================================================================
File: internal/infrastructure/tracer/tracer.go
Size: 3.81 kB
================================================================================

package tracer

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/dmarins/student-api/internal/infrastructure/env"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	"go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	oteltrace "go.opentelemetry.io/otel/trace"
)

type OtelSpanWrapper struct {
	oteltrace.Span
}

func (s OtelSpanWrapper) End() {
	s.Span.End()
}

func (s OtelSpanWrapper) AddEvent(name string, opts ...interface{}) {
	s.Span.AddEvent(name)
}

type (
	ITracer interface {
		NewRootSpan(request *http.Request, spanName string) (ISpan, context.Context)
		NewSpanContext(ctx context.Context, spanName string) (ISpan, context.Context)
		AddAttributes(span ISpan, name string, attributes Attributes)
		Shutdown(ctx context.Context, logger logger.ILogger)
	}

	Tracer struct {
		provider *trace.TracerProvider
	}

	Attributes map[string]interface {
	}
)

func NewTracer(ctx context.Context, logger logger.ILogger) ITracer {
	var endpointOption otlptracegrpc.Option
	appName := env.ProvideAppName()
	env := env.ProvideAppEnv()
	if env == "local" {
		endpointOption = otlptracegrpc.WithEndpoint("localhost:4317")
	} else {
		endpointOption = otlptracegrpc.WithEndpoint("otel-collector:4317")
	}

	exporter, err := otlptracegrpc.
		New(
			ctx,
			endpointOption,
			otlptracegrpc.WithInsecure(),
		)
	if err != nil {
		logger.Fatal(ctx, "failed to initialize tracer", err)
	}

	tp := trace.
		NewTracerProvider(
			trace.WithBatcher(exporter),
			trace.WithResource(resource.NewWithAttributes(
				semconv.SchemaURL,
				semconv.ServiceNameKey.String(appName),
			)),
		)

	otel.SetTracerProvider(tp)
	otel.SetTextMapPropagator(propagation.TraceContext{})

	return &Tracer{
		provider: tp,
	}
}

func convertAttributes(attributes Attributes) []attribute.KeyValue {
	values := make([]attribute.KeyValue, 0, len(attributes))

	for k, v := range attributes {

		switch t := v.(type) {
		case string:
			values = append(values, attribute.String(k, t))
			continue
		case int:
			values = append(values, attribute.Int(k, t))
			continue
		case int64:
			values = append(values, attribute.Int64(k, t))
			continue
		case bool:
			values = append(values, attribute.Bool(k, t))
			continue
		default:
			val, err := json.Marshal(v)
			if err != nil {
				continue
			}

			values = append(values, attribute.String(k, string(val)))
		}

	}

	return values
}

func (t *Tracer) NewRootSpan(request *http.Request, spanName string) (ISpan, context.Context) {
	ctx := otel.
		GetTextMapPropagator().
		Extract(request.Context(), propagation.HeaderCarrier(request.Header))

	return t.NewSpanContext(ctx, spanName)
}

func (t *Tracer) NewSpanContext(ctx context.Context, spanName string) (ISpan, context.Context) {
	appName := env.ProvideAppEnv()
	tracer := otel.Tracer(appName)

	commonLabels := []attribute.KeyValue{
		attribute.String("service.name", appName),
	}

	ctx, span := tracer.Start(
		ctx,
		spanName,
		oteltrace.WithAttributes(commonLabels...),
	)

	span.SetStatus(codes.Ok, spanName)

	return OtelSpanWrapper{span}, ctx
}

func (t *Tracer) AddAttributes(span ISpan, name string, attributes Attributes) {
	values := convertAttributes(attributes)

	span.AddEvent(name, oteltrace.WithAttributes(values...))
}

func (t *Tracer) Shutdown(ctx context.Context, logger logger.ILogger) {
	if t.provider != nil {
		err := t.provider.Shutdown(ctx)
		if err != nil {
			logger.Error(ctx, "failed to shutdown tracer", err)
			return
		}
	}

	logger.Info(ctx, "tracer shutdown completed successfully")
}


================================================================================
File: internal/infrastructure/uuid/uuid.go
Size: 178 B
================================================================================

package uuid

import "github.com/google/uuid"

func NewId() string {
	return uuid.New().String()
}

func IsValid(id string) bool {
	_, err := uuid.Parse(id)
	return err == nil
}


================================================================================
File: internal/usecases/healthcheck/healthcheck.go
Size: 1.23 kB
================================================================================

package healthcheck

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type HealthCheck struct {
	HealthCheckRepository repositories.IHealthCheckRepository
	Tracer                tracer.ITracer
	Logger                logger.ILogger
}

func NewHealthCheck(tracer tracer.ITracer, logger logger.ILogger, healthCheckRepository repositories.IHealthCheckRepository) usecases.IHealthCheckUseCase {
	return &HealthCheck{
		HealthCheckRepository: healthCheckRepository,
		Tracer:                tracer,
		Logger:                logger,
	}
}

func (uc *HealthCheck) Execute(ctx context.Context) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.HealthCheckExecute)
	defer span.End()

	err := uc.HealthCheckRepository.CheckDbConnection(ctx)
	if err != nil {
		uc.Logger.Error(ctx, "error checking db connection", err)

		return dtos.NewInternalServerErrorResult()
	}

	result := dtos.NewOkResult(nil)
	result.Message = "healthy"

	return result
}


================================================================================
File: internal/usecases/healthcheck/healthcheck_test.go
Size: 1.36 kB
================================================================================

package healthcheck_test

import (
	"errors"
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

var fakeError error = errors.New("fails")

func TestHealthCheckUseCase_Execute_WhenRepositoryFailsToCheckDbConnection(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.HealthCheckExecute).
		SettingLoggerErrorBehavior("error checking db connection", fakeError)

	builder.HealthCheckRepositoryMock.
		EXPECT().
		CheckDbConnection(builder.Ctx).
		Return(fakeError)

	sut := builder.BuildHealthCheckUseCase()

	result := sut.Execute(builder.Ctx)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestHealthCheckUseCase_Execute_WhenRepositoryCheckDbConnection(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.HealthCheckExecute)

	builder.HealthCheckRepositoryMock.
		EXPECT().
		CheckDbConnection(builder.Ctx).
		Return(nil)

	sut := builder.BuildHealthCheckUseCase()

	result := sut.Execute(builder.Ctx)

	expectedResult := dtos.NewOkResult(nil)
	expectedResult.Message = "healthy"

	assert.EqualValues(t, expectedResult, result)
}


================================================================================
File: internal/usecases/student/create/main_test.go
Size: 700 B
================================================================================

package create_test

import (
	"errors"
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
)

type fakeValues struct {
	fakeStudentCreateInput dtos.StudentCreateInput
	fakeError              error
}

var f *fakeValues

// TestMain will run before all the tests in the package creation_test
func TestMain(m *testing.M) {
	// Setup: Creating fake values
	fakeStudentCreateInput := dtos.StudentCreateInput{
		Name: "John Doe",
	}

	f = &fakeValues{
		fakeStudentCreateInput: fakeStudentCreateInput,
		fakeError:              errors.New("fails"),
	}

	// Run the all tests in the package creation_test
	code := m.Run()

	// Exit with the code returned by the tests
	os.Exit(code)
}


================================================================================
File: internal/usecases/student/create/with_name_check.go
Size: 1.76 kB
================================================================================

package create

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentCreateWithNameCheck struct {
	StudentRepository repositories.IStudentRepository
	Tracer            tracer.ITracer
	Logger            logger.ILogger
	Next              usecases.IStudentCreateUseCase
}

func NewStudentCreateWithNameCheck(tracer tracer.ITracer,
	logger logger.ILogger,
	studentRepository repositories.IStudentRepository,
	next usecases.IStudentCreateUseCase) usecases.IStudentCreateUseCase {
	return &StudentCreateWithNameCheck{
		StudentRepository: studentRepository,
		Tracer:            tracer,
		Logger:            logger,
		Next:              next,
	}
}

func (uc *StudentCreateWithNameCheck) Execute(ctx context.Context, studentCreateInput dtos.StudentCreateInput) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentCreateUseCaseValidationsExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentCreateUseCaseValidationsExecute,
		tracer.Attributes{
			"Payload": studentCreateInput,
		})

	exists, err := uc.StudentRepository.ExistsByName(ctx, studentCreateInput.Name)
	if err != nil {
		uc.Logger.Error(ctx, "error checking if student exists", err, "name", studentCreateInput.Name)

		return dtos.NewInternalServerErrorResult()
	}

	if exists {
		uc.Logger.Warn(ctx, "there is already a student with the same name", "name", studentCreateInput.Name)

		return dtos.NewConflictResult()
	}

	return uc.Next.Execute(ctx, studentCreateInput)
}


================================================================================
File: internal/usecases/student/create/with_name_check_test.go
Size: 2.95 kB
================================================================================

package create_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

func TestStudentCreateWithNameCheck_Execute_WhenTheRepositoryFailsToCheckIfTheStudentExists(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentCreateUseCaseValidationsExecute).
		SettingLoggerErrorBehavior("error checking if student exists", f.fakeError, "name", f.fakeStudentCreateInput.Name)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentCreateInput.Name).
		Return(false, f.fakeError)

	sut := builder.BuildStudentCreateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentCreateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentCreateWithNameCheck_Execute_WhenTheStudentAlreadyExists(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentCreateUseCaseValidationsExecute).
		SettingLoggerWarnBehavior("there is already a student with the same name", "name", f.fakeStudentCreateInput.Name)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentCreateInput.Name).
		Return(true, nil)

	sut := builder.BuildStudentCreateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentCreateInput)

	assert.EqualValues(t, dtos.NewConflictResult(), result)
}

func TestStudentCreateWithNameCheck_Execute_WhenAnErrorIsReturnedByTheNextDecorator(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentCreateUseCaseValidationsExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentCreateInput.Name).
		Return(false, nil)

	builder.StudentCreateUseCaseMock.
		EXPECT().
		Execute(builder.Ctx, f.fakeStudentCreateInput).
		Return(dtos.NewInternalServerErrorResult())

	sut := builder.BuildStudentCreateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentCreateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentCreateWithNameCheck_Execute_WhenTheStudentDoesNotExist(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentCreateUseCaseValidationsExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentCreateInput.Name).
		Return(false, nil)

	builder.StudentCreateUseCaseMock.
		EXPECT().
		Execute(builder.Ctx, f.fakeStudentCreateInput).
		Return(dtos.NewCreatedResult(f.fakeStudentCreateInput))

	sut := builder.BuildStudentCreateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentCreateInput)

	assert.EqualValues(t, dtos.NewCreatedResult(result.Data), result)
}


================================================================================
File: internal/usecases/student/create/with_persistence.go
Size: 1.69 kB
================================================================================

package create

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentCreateWithPersistence struct {
	StudentRepository repositories.IStudentRepository
	Tracer            tracer.ITracer
	Logger            logger.ILogger
}

func NewStudentCreateWithPersistence(tracer tracer.ITracer, logger logger.ILogger, studentRepository repositories.IStudentRepository) usecases.IStudentCreateUseCase {
	return &StudentCreateWithPersistence{
		StudentRepository: studentRepository,
		Tracer:            tracer,
		Logger:            logger,
	}
}

func (uc *StudentCreateWithPersistence) Execute(ctx context.Context, studentCreateInput dtos.StudentCreateInput) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentCreateUseCasePersistenceExecute)
	defer span.End()

	student := entities.NewStudent(studentCreateInput.Name)

	uc.Logger.Debug(ctx, "new student", "id", student.ID)

	uc.Tracer.AddAttributes(span, tracer.StudentCreateUseCasePersistenceExecute,
		tracer.Attributes{
			"Entity": student,
		})

	err := uc.StudentRepository.Add(ctx, student)
	if err != nil {
		uc.Logger.Error(ctx, "error adding a new student", err)

		return dtos.NewInternalServerErrorResult()
	}

	uc.Logger.Debug(ctx, "student stored")

	output := &dtos.StudentOutput{
		ID:   student.ID,
		Name: student.Name,
	}

	return dtos.NewCreatedResult(output)
}


================================================================================
File: internal/usecases/student/create/with_persistence_test.go
Size: 1.56 kB
================================================================================

package create_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
)

func TestStudentCreateWithPersistence_Execute_WhenRepositoryFailsToAddStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingLoggerDebugBehavior("new student", "id", gomock.Any()).
		SettingTracerBehavior(tracer.StudentCreateUseCasePersistenceExecute).
		SettingLoggerErrorBehavior("error adding a new student", f.fakeError)

	builder.StudentRepositoryMock.
		EXPECT().
		Add(builder.Ctx, gomock.Any()).
		Return(f.fakeError)

	sut := builder.BuildStudentCreateWithPersistence()

	result := sut.Execute(builder.Ctx, f.fakeStudentCreateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentCreateWithPersistence_Execute_WhenRepositoryAddsTheStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentCreateUseCasePersistenceExecute).
		SettingLoggerDebugBehavior("new student", "id", gomock.Any()).
		SettingLoggerDebugBehavior("student stored")

	builder.StudentRepositoryMock.
		EXPECT().
		Add(builder.Ctx, gomock.Any()).
		Return(nil)

	sut := builder.BuildStudentCreateWithPersistence()

	result := sut.Execute(builder.Ctx, f.fakeStudentCreateInput)

	assert.EqualValues(t, dtos.NewCreatedResult(result.Data), result)
}


================================================================================
File: internal/usecases/student/delete/main_test.go
Size: 791 B
================================================================================

package delete_test

import (
	"errors"
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/domain/entities"
)

type fakeValues struct {
	fakeStudent            entities.Student
	fakeError              error
	fakeStudentToBeDeleted string
}

var f *fakeValues

// TestMain will run before all the tests in the package creation_test
func TestMain(m *testing.M) {
	// Setup: Creating fake values
	fakeStudent := entities.Student{
		ID: "58ecde02-18f6-4896-a716-64abf6724587",
	}

	f = &fakeValues{
		fakeStudent:            fakeStudent,
		fakeError:              errors.New("fails"),
		fakeStudentToBeDeleted: "8e99273f-e566-4476-836e-048b1ecd9c4d",
	}

	// Run the all tests in the package creation_test
	code := m.Run()

	// Exit with the code returned by the tests
	os.Exit(code)
}


================================================================================
File: internal/usecases/student/delete/with_find_by_id.go
Size: 1.66 kB
================================================================================

package delete

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentDeleteWithFindById struct {
	Tracer            tracer.ITracer
	Logger            logger.ILogger
	StudentRepository repositories.IStudentRepository
	Next              usecases.IStudentDeleteUseCase
}

func NewStudentDeleteWithFindById(tracer tracer.ITracer,
	logger logger.ILogger,
	studentRepository repositories.IStudentRepository,
	next usecases.IStudentDeleteUseCase) usecases.IStudentDeleteUseCase {
	return &StudentDeleteWithFindById{
		Tracer:            tracer,
		Logger:            logger,
		StudentRepository: studentRepository,
		Next:              next,
	}
}

func (uc *StudentDeleteWithFindById) Execute(ctx context.Context, studentId string) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentDeleteUseCaseFindByIdExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentDeleteUseCaseFindByIdExecute,
		tracer.Attributes{
			"ID": studentId,
		})

	student, err := uc.StudentRepository.FindById(ctx, studentId)
	if err != nil {
		uc.Logger.Error(ctx, "error finding student by id", err, "id", studentId)

		return dtos.NewInternalServerErrorResult()
	}

	if student == nil {
		uc.Logger.Warn(ctx, "the student was not found according to the id provided", "id", studentId)

		return dtos.NewNotFoundResult()
	}

	return uc.Next.Execute(ctx, studentId)
}


================================================================================
File: internal/usecases/student/delete/with_find_by_id_test.go
Size: 2.17 kB
================================================================================

package delete_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

func TestStudentDeleteWithFindById_Execute_WhenTheRepositoryFailsToFindTheStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentDeleteUseCaseFindByIdExecute).
		SettingLoggerErrorBehavior("error finding student by id", f.fakeError, "id", f.fakeStudentToBeDeleted)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudentToBeDeleted).
		Return(nil, f.fakeError)

	sut := builder.BuildStudentDeleteWithFindById()

	result := sut.Execute(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentDeleteWithFindById_Execute_WhenTheStudentIsNotFound(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentDeleteUseCaseFindByIdExecute).
		SettingLoggerWarnBehavior("the student was not found according to the id provided", "id", f.fakeStudentToBeDeleted)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudentToBeDeleted).
		Return(nil, nil)

	sut := builder.BuildStudentDeleteWithFindById()

	result := sut.Execute(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.EqualValues(t, dtos.NewNotFoundResult(), result)
}

func TestStudentDeleteWithFindById_Execute_WhenTheStudentIsFound(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentDeleteUseCaseFindByIdExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudentToBeDeleted).
		Return(&f.fakeStudent, nil)

	builder.StudentDeleteUseCaseMock.
		EXPECT().
		Execute(builder.Ctx, f.fakeStudentToBeDeleted).
		Return(dtos.NewNoCotentResult())

	sut := builder.BuildStudentDeleteWithFindById()

	result := sut.Execute(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.EqualValues(t, dtos.NewNoCotentResult(), result)
}


================================================================================
File: internal/usecases/student/delete/with_persistence.go
Size: 1.41 kB
================================================================================

package delete

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentDeleteWithPersistence struct {
	StudentRepository repositories.IStudentRepository
	Tracer            tracer.ITracer
	Logger            logger.ILogger
}

func NewStudentDeleteWithPersistence(tracer tracer.ITracer, logger logger.ILogger, studentRepository repositories.IStudentRepository) usecases.IStudentDeleteUseCase {
	return &StudentDeleteWithPersistence{
		StudentRepository: studentRepository,
		Tracer:            tracer,
		Logger:            logger,
	}
}

func (uc *StudentDeleteWithPersistence) Execute(ctx context.Context, studentId string) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentDeleteUseCasePersistenceExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentDeleteUseCasePersistenceExecute,
		tracer.Attributes{
			"ID": studentId,
		})

	err := uc.StudentRepository.Delete(ctx, studentId)
	if err != nil {
		uc.Logger.Error(ctx, "error deleting a student", err)

		return dtos.NewInternalServerErrorResult()
	}

	uc.Logger.Debug(ctx, "student deleted")

	return dtos.NewNoCotentResult()
}


================================================================================
File: internal/usecases/student/delete/with_persistence_test.go
Size: 1.43 kB
================================================================================

package delete_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
)

func TestStudentDeleteWithPersistence_Execute_WhenRepositoryFailsToDeleteStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentDeleteUseCasePersistenceExecute).
		SettingLoggerErrorBehavior("error deleting a student", f.fakeError)

	builder.StudentRepositoryMock.
		EXPECT().
		Delete(builder.Ctx, gomock.Any()).
		Return(f.fakeError)

	sut := builder.BuildStudentDeleteWithPersistence()

	result := sut.Execute(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentDeleteWithPersistence_Execute_WhenRepositoryRemovesTheStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentDeleteUseCasePersistenceExecute).
		SettingLoggerDebugBehavior("student deleted")

	builder.StudentRepositoryMock.
		EXPECT().
		Delete(builder.Ctx, gomock.Any()).
		Return(nil)

	sut := builder.BuildStudentDeleteWithPersistence()

	result := sut.Execute(builder.Ctx, f.fakeStudentToBeDeleted)

	assert.EqualValues(t, dtos.NewNoCotentResult(), result)
}


================================================================================
File: internal/usecases/student/read/main_test.go
Size: 648 B
================================================================================

package read_test

import (
	"errors"
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/domain/entities"
)

type fakeValues struct {
	fakeStudent entities.Student
	fakeError   error
}

var f *fakeValues

// TestMain will run before all the tests in the package creation_test
func TestMain(m *testing.M) {
	// Setup: Creating fake values
	fakeStudent := entities.Student{
		ID: "58ecde02-18f6-4896-a716-64abf6724587",
	}

	f = &fakeValues{
		fakeStudent: fakeStudent,
		fakeError:   errors.New("fails"),
	}

	// Run the all tests in the package creation_test
	code := m.Run()

	// Exit with the code returned by the tests
	os.Exit(code)
}


================================================================================
File: internal/usecases/student/read/with_find_by_id.go
Size: 1.6 kB
================================================================================

package read

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentReadWithFindById struct {
	Tracer            tracer.ITracer
	Logger            logger.ILogger
	StudentRepository repositories.IStudentRepository
}

func NewStudentReadWithFindById(tracer tracer.ITracer, logger logger.ILogger, studentRepository repositories.IStudentRepository) usecases.IStudentReadUseCase {
	return &StudentReadWithFindById{
		Tracer:            tracer,
		Logger:            logger,
		StudentRepository: studentRepository,
	}
}

func (uc *StudentReadWithFindById) Execute(ctx context.Context, studentId string) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentReadUseCaseFindByIdExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentReadUseCaseFindByIdExecute,
		tracer.Attributes{
			"ID": studentId,
		})

	student, err := uc.StudentRepository.FindById(ctx, studentId)
	if err != nil {
		uc.Logger.Error(ctx, "error finding student by id", err, "id", studentId)

		return dtos.NewInternalServerErrorResult()
	}

	if student == nil {
		uc.Logger.Warn(ctx, "the student was not found according to the id provided", "id", studentId)

		return dtos.NewNotFoundResult()
	}

	output := &dtos.StudentOutput{
		ID:   student.ID,
		Name: student.Name,
	}

	return dtos.NewOkResult(output)
}


================================================================================
File: internal/usecases/student/read/with_find_by_id_test.go
Size: 1.96 kB
================================================================================

package read_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

func TestStudentReadWithFindById_Execute_WhenTheRepositoryFailsToFindTheStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentReadUseCaseFindByIdExecute).
		SettingLoggerErrorBehavior("error finding student by id", f.fakeError, "id", f.fakeStudent.ID)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudent.ID).
		Return(nil, f.fakeError)

	sut := builder.BuildStudentReadWithFindByID()

	result := sut.Execute(builder.Ctx, f.fakeStudent.ID)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentReadWithFindById_Execute_WhenTheStudentIsNotFound(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentReadUseCaseFindByIdExecute).
		SettingLoggerWarnBehavior("the student was not found according to the id provided", "id", f.fakeStudent.ID)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudent.ID).
		Return(nil, nil)

	sut := builder.BuildStudentReadWithFindByID()

	result := sut.Execute(builder.Ctx, f.fakeStudent.ID)

	assert.EqualValues(t, dtos.NewNotFoundResult(), result)
}

func TestStudentReadWithFindById_Execute_WhenTheStudentIsFound(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentReadUseCaseFindByIdExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudent.ID).
		Return(&f.fakeStudent, nil)

	sut := builder.BuildStudentReadWithFindByID()

	result := sut.Execute(builder.Ctx, f.fakeStudent.ID)

	assert.EqualValues(t, dtos.NewOkResult(result.Data), result)
}


================================================================================
File: internal/usecases/student/read/with_search_by.go
Size: 1.89 kB
================================================================================

package read

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentSearchWithSearchBy struct {
	Tracer            tracer.ITracer
	Logger            logger.ILogger
	StudentRepository repositories.IStudentRepository
}

func NewStudentSearchWithSearchBy(tracer tracer.ITracer, logger logger.ILogger, studentRepository repositories.IStudentRepository) usecases.IStudentSearchUseCase {
	return &StudentSearchWithSearchBy{
		Tracer:            tracer,
		Logger:            logger,
		StudentRepository: studentRepository,
	}
}

func (uc *StudentSearchWithSearchBy) Execute(ctx context.Context, pagination dtos.PaginationInput, filter dtos.Filter) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentSearchUseCaseSearchByExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentSearchUseCaseSearchByExecute,
		tracer.Attributes{
			"Pagination": pagination,
			"Filter":     filter,
		})

	count, err := uc.StudentRepository.Count(ctx, filter)
	if err != nil {
		uc.Logger.Error(ctx, "error counting students", err)

		return dtos.NewInternalServerErrorResult()
	}

	if count <= 0 {
		paginationResponse := dtos.NewPaginationOutput(0, pagination.Page, pagination.PageSize, nil)
		return dtos.NewOkResult(paginationResponse)
	}

	students, err := uc.StudentRepository.SearchBy(ctx, pagination, filter)
	if err != nil {
		uc.Logger.Error(ctx, "error searching students", err)

		return dtos.NewInternalServerErrorResult()
	}

	paginationResponse := dtos.NewPaginationOutput(count, pagination.Page, pagination.PageSize, students)
	return dtos.NewOkResult(paginationResponse)
}


================================================================================
File: internal/usecases/student/read/with_search_by_test.go
Size: 3.68 kB
================================================================================

package read_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

func TestStudentSearchWithSearchBy_Execute_WhenCountFails(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentSearchUseCaseSearchByExecute).
		SettingLoggerErrorBehavior("error counting students", f.fakeError)

	pagination := dtos.PaginationInput{
		Page:      1,
		PageSize:  10,
		SortOrder: tests.ToPointer("asc"),
		SortField: tests.ToPointer("name"),
	}

	filter := dtos.Filter{
		Name: tests.ToPointer("thompson"),
	}

	builder.StudentRepositoryMock.
		EXPECT().
		Count(builder.Ctx, filter).
		Return(0, f.fakeError)

	sut := builder.BuildStudentSearchWithSearchBy()

	result := sut.Execute(builder.Ctx, pagination, filter)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentSearchWithSearchBy_Execute_WhenCountReturnsZero(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentSearchUseCaseSearchByExecute)

	pagination := dtos.PaginationInput{
		Page:      1,
		PageSize:  10,
		SortOrder: tests.ToPointer("asc"),
		SortField: tests.ToPointer("name"),
	}

	filter := dtos.Filter{
		Name: tests.ToPointer("thompson"),
	}

	builder.StudentRepositoryMock.
		EXPECT().
		Count(builder.Ctx, filter).
		Return(0, nil)

	builder.StudentRepositoryMock.
		EXPECT().
		SearchBy(builder.Ctx, pagination, filter).
		Times(0)

	sut := builder.BuildStudentSearchWithSearchBy()

	result := sut.Execute(builder.Ctx, pagination, filter)

	assert.EqualValues(t, dtos.NewOkResult(result.Data), result)
}

func TestStudentSearchWithSearchBy_Execute_WhenSearchByFails(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentSearchUseCaseSearchByExecute).
		SettingLoggerErrorBehavior("error searching students", f.fakeError)

	pagination := dtos.PaginationInput{
		Page:      1,
		PageSize:  10,
		SortOrder: tests.ToPointer("asc"),
		SortField: tests.ToPointer("name"),
	}

	filter := dtos.Filter{
		Name: tests.ToPointer("thompson"),
	}

	builder.StudentRepositoryMock.
		EXPECT().
		Count(builder.Ctx, filter).
		Return(2, nil)

	builder.StudentRepositoryMock.
		EXPECT().
		SearchBy(builder.Ctx, pagination, filter).
		Return(nil, f.fakeError)

	sut := builder.BuildStudentSearchWithSearchBy()

	result := sut.Execute(builder.Ctx, pagination, filter)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentSearchWithSearchBy_Execute_WhenSearchByReturnsAsExpected(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentSearchUseCaseSearchByExecute)

	pagination := dtos.PaginationInput{
		Page:      1,
		PageSize:  10,
		SortOrder: tests.ToPointer("asc"),
		SortField: tests.ToPointer("name"),
	}

	filter := dtos.Filter{
		Name: tests.ToPointer("thompson"),
	}

	builder.StudentRepositoryMock.
		EXPECT().
		Count(builder.Ctx, filter).
		Return(2, nil)

	builder.StudentRepositoryMock.
		EXPECT().
		SearchBy(builder.Ctx, pagination, filter).
		Return([]*entities.Student{
			{
				ID:   "a",
				Name: "student 1",
			},
			{
				ID:   "b",
				Name: "student 2",
			},
		}, nil)

	sut := builder.BuildStudentSearchWithSearchBy()

	result := sut.Execute(builder.Ctx, pagination, filter)

	assert.EqualValues(t, dtos.NewOkResult(result.Data), result)
}


================================================================================
File: internal/usecases/student/update/main_test.go
Size: 922 B
================================================================================

package update_test

import (
	"errors"
	"os"
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
)

type fakeValues struct {
	fakeStudentUpdateInput dtos.StudentUpdateInput
	fakeStudent            entities.Student
	fakeError              error
}

var f *fakeValues

// TestMain will run before all the tests in the package creation_test
func TestMain(m *testing.M) {
	// Setup: Creating fake values
	fakeStudentUpdateInput := dtos.StudentUpdateInput{
		Name: "John Doe",
	}
	fakeStudent := entities.Student{
		ID: "58ecde02-18f6-4896-a716-64abf6724587",
	}

	f = &fakeValues{
		fakeStudentUpdateInput: fakeStudentUpdateInput,
		fakeStudent:            fakeStudent,
		fakeError:              errors.New("fails"),
	}

	// Run the all tests in the package creation_test
	code := m.Run()

	// Exit with the code returned by the tests
	os.Exit(code)
}


================================================================================
File: internal/usecases/student/update/with_find_by_id.go
Size: 1.75 kB
================================================================================

package update

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentUpdateWithFindById struct {
	StudentRepository repositories.IStudentRepository
	Tracer            tracer.ITracer
	Logger            logger.ILogger
	Next              usecases.IStudentUpdateUseCase
}

func NewStudentUpdateWithFindById(tracer tracer.ITracer,
	logger logger.ILogger,
	studentRepository repositories.IStudentRepository,
	next usecases.IStudentUpdateUseCase) usecases.IStudentUpdateUseCase {
	return &StudentUpdateWithFindById{
		StudentRepository: studentRepository,
		Tracer:            tracer,
		Logger:            logger,
		Next:              next,
	}
}

func (uc *StudentUpdateWithFindById) Execute(ctx context.Context, studentUpdateInput dtos.StudentUpdateInput) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentUpdateUseCaseValidationsExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentUpdateUseCaseValidationsExecute,
		tracer.Attributes{
			"Payload": studentUpdateInput,
		})

	student, err := uc.StudentRepository.FindById(ctx, studentUpdateInput.ID)
	if err != nil {
		uc.Logger.Error(ctx, "error finding student by id", err, "id", studentUpdateInput.ID)

		return dtos.NewInternalServerErrorResult()
	}

	if student == nil {
		uc.Logger.Warn(ctx, "the student was not found according to the id provided", "id", studentUpdateInput.ID)

		return dtos.NewNotFoundResult()
	}

	return uc.Next.Execute(ctx, studentUpdateInput)
}


================================================================================
File: internal/usecases/student/update/with_find_by_id_test.go
Size: 2.22 kB
================================================================================

package update_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

func TestStudentUpdateWithFindById_Execute_WhenTheRepositoryFailsToFindTheStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute).
		SettingLoggerErrorBehavior("error finding student by id", f.fakeError, "id", f.fakeStudentUpdateInput.ID)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudentUpdateInput.ID).
		Return(nil, f.fakeError)

	sut := builder.BuildStudentUpdateWithFindById()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentUpdateWithFindById_Execute_WhenTheStudentIsNotFound(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute).
		SettingLoggerWarnBehavior("the student was not found according to the id provided", "id", f.fakeStudentUpdateInput.ID)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudentUpdateInput.ID).
		Return(nil, nil)

	sut := builder.BuildStudentUpdateWithFindById()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewNotFoundResult(), result)
}

func TestStudentUpdateWithFindById_Execute_WhenTheStudentIsFound(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		FindById(builder.Ctx, f.fakeStudentUpdateInput.ID).
		Return(&f.fakeStudent, nil)

	builder.StudentUpdateUseCaseMock.
		EXPECT().
		Execute(builder.Ctx, f.fakeStudentUpdateInput).
		Return(dtos.NewOkResult(f.fakeStudentUpdateInput))

	sut := builder.BuildStudentUpdateWithFindById()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewOkResult(result.Data), result)
}


================================================================================
File: internal/usecases/student/update/with_name_check.go
Size: 1.76 kB
================================================================================

package update

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentUpdateWithNameCheck struct {
	StudentRepository repositories.IStudentRepository
	Tracer            tracer.ITracer
	Logger            logger.ILogger
	Next              usecases.IStudentUpdateUseCase
}

func NewStudentUpdateWithNameCheck(tracer tracer.ITracer,
	logger logger.ILogger,
	studentRepository repositories.IStudentRepository,
	next usecases.IStudentUpdateUseCase) usecases.IStudentUpdateUseCase {
	return &StudentUpdateWithNameCheck{
		StudentRepository: studentRepository,
		Tracer:            tracer,
		Logger:            logger,
		Next:              next,
	}
}

func (uc *StudentUpdateWithNameCheck) Execute(ctx context.Context, studentUpdateInput dtos.StudentUpdateInput) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentUpdateUseCaseValidationsExecute)
	defer span.End()

	uc.Tracer.AddAttributes(span, tracer.StudentUpdateUseCaseValidationsExecute,
		tracer.Attributes{
			"Payload": studentUpdateInput,
		})

	exists, err := uc.StudentRepository.ExistsByName(ctx, studentUpdateInput.Name)
	if err != nil {
		uc.Logger.Error(ctx, "error checking if student exists", err, "name", studentUpdateInput.Name)

		return dtos.NewInternalServerErrorResult()
	}

	if exists {
		uc.Logger.Warn(ctx, "there is already a student with the same name", "name", studentUpdateInput.Name)

		return dtos.NewConflictResult()
	}

	return uc.Next.Execute(ctx, studentUpdateInput)
}


================================================================================
File: internal/usecases/student/update/with_name_check_test.go
Size: 2.95 kB
================================================================================

package update_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
)

func TestStudentUpdateWithNameCheck_Execute_WhenTheRepositoryFailsToCheckIfTheStudentExists(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute).
		SettingLoggerErrorBehavior("error checking if student exists", f.fakeError, "name", f.fakeStudentUpdateInput.Name)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentUpdateInput.Name).
		Return(false, f.fakeError)

	sut := builder.BuildStudentUpdateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentUpdateWithNameCheck_Execute_WhenTheStudentAlreadyExists(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute).
		SettingLoggerWarnBehavior("there is already a student with the same name", "name", f.fakeStudentUpdateInput.Name)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentUpdateInput.Name).
		Return(true, nil)

	sut := builder.BuildStudentUpdateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewConflictResult(), result)
}

func TestStudentUpdateWithNameCheck_Execute_WhenAnErrorIsReturnedByTheNextDecorator(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentUpdateInput.Name).
		Return(false, nil)

	builder.StudentUpdateUseCaseMock.
		EXPECT().
		Execute(builder.Ctx, f.fakeStudentUpdateInput).
		Return(dtos.NewInternalServerErrorResult())

	sut := builder.BuildStudentUpdateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentUpdateWithNameCheck_Execute_WhenTheStudentDoesNotExist(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCaseValidationsExecute)

	builder.StudentRepositoryMock.
		EXPECT().
		ExistsByName(builder.Ctx, f.fakeStudentUpdateInput.Name).
		Return(false, nil)

	builder.StudentUpdateUseCaseMock.
		EXPECT().
		Execute(builder.Ctx, f.fakeStudentUpdateInput).
		Return(dtos.NewCreatedResult(f.fakeStudentUpdateInput))

	sut := builder.BuildStudentUpdateWithNameCheck()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewCreatedResult(result.Data), result)
}


================================================================================
File: internal/usecases/student/update/with_persistence.go
Size: 1.67 kB
================================================================================

package update

import (
	"context"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/domain/entities"
	"github.com/dmarins/student-api/internal/domain/repositories"
	"github.com/dmarins/student-api/internal/domain/usecases"
	"github.com/dmarins/student-api/internal/infrastructure/logger"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
)

type StudentUpdateWithPersistence struct {
	StudentRepository repositories.IStudentRepository
	Tracer            tracer.ITracer
	Logger            logger.ILogger
}

func NewStudentUpdateWithPersistence(tracer tracer.ITracer, logger logger.ILogger, studentRepository repositories.IStudentRepository) usecases.IStudentUpdateUseCase {
	return &StudentUpdateWithPersistence{
		StudentRepository: studentRepository,
		Tracer:            tracer,
		Logger:            logger,
	}
}

func (uc *StudentUpdateWithPersistence) Execute(ctx context.Context, studentUpdateInput dtos.StudentUpdateInput) *dtos.Result {
	span, ctx := uc.Tracer.NewSpanContext(ctx, tracer.StudentUpdateUseCasePersistenceExecute)
	defer span.End()

	student := &entities.Student{
		ID:   studentUpdateInput.ID,
		Name: studentUpdateInput.Name,
	}

	uc.Tracer.AddAttributes(span, tracer.StudentUpdateUseCasePersistenceExecute,
		tracer.Attributes{
			"Entity": student,
		})

	err := uc.StudentRepository.Update(ctx, student)
	if err != nil {
		uc.Logger.Error(ctx, "error updating a student", err)

		return dtos.NewInternalServerErrorResult()
	}

	uc.Logger.Debug(ctx, "student updated")

	output := &dtos.StudentOutput{
		ID:   student.ID,
		Name: student.Name,
	}

	return dtos.NewOkResult(output)
}


================================================================================
File: internal/usecases/student/update/with_persistence_test.go
Size: 1.43 kB
================================================================================

package update_test

import (
	"testing"

	"github.com/dmarins/student-api/internal/domain/dtos"
	"github.com/dmarins/student-api/internal/infrastructure/tests"
	"github.com/dmarins/student-api/internal/infrastructure/tracer"
	"github.com/stretchr/testify/assert"
	"go.uber.org/mock/gomock"
)

func TestStudentUpdateWithPersistence_Execute_WhenRepositoryFailsToAddStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCasePersistenceExecute).
		SettingLoggerErrorBehavior("error updating a student", f.fakeError)

	builder.StudentRepositoryMock.
		EXPECT().
		Update(builder.Ctx, gomock.Any()).
		Return(f.fakeError)

	sut := builder.BuildStudentUpdateWithPersistence()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewInternalServerErrorResult(), result)
}

func TestStudentUpdateWithPersistence_Execute_WhenRepositoryAddsTheStudent(t *testing.T) {
	builder := tests.NewUnitTestsBuilder(t).
		WithValidCtx().
		SettingTracerBehavior(tracer.StudentUpdateUseCasePersistenceExecute).
		SettingLoggerDebugBehavior("student updated")

	builder.StudentRepositoryMock.
		EXPECT().
		Update(builder.Ctx, gomock.Any()).
		Return(nil)

	sut := builder.BuildStudentUpdateWithPersistence()

	result := sut.Execute(builder.Ctx, f.fakeStudentUpdateInput)

	assert.EqualValues(t, dtos.NewOkResult(result.Data), result)
}


================================================================================
File: migrations/000001_create_students_table.down.sql
Size: 30 B
================================================================================

DROP TABLE IF EXISTS students;

================================================================================
File: migrations/000001_create_students_table.up.sql
Size: 124 B
================================================================================

CREATE TABLE IF NOT EXISTS students (
    id VARCHAR(36) NOT NULL, 
    name VARCHAR(200) NOT NULL, 
    PRIMARY KEY (id)
);

================================================================================
File: migrations/000002_insert_students.down.sql
Size: 309 B
================================================================================

BEGIN;

DELETE FROM 
    students 
WHERE 
    id IN (
        'bcff9f56-1ba6-4f92-9478-635c3f18e558',
        'dbf54856-9a98-4672-9c90-e9da71a1f893',
        '06b2ec25-3fe0-475e-9077-e77a113f4727',
        'e6e84c46-6ddf-4d9a-b27a-ddb74b4d63bb',
        '8e99273f-e566-4476-836e-048b1ecd9c4d'
    );

COMMIT;


================================================================================
File: migrations/000002_insert_students.up.sql
Size: 464 B
================================================================================

BEGIN;

INSERT INTO 
    students (id, name) 
VALUES
    ('bcff9f56-1ba6-4f92-9478-635c3f18e558', 'bob'),
    ('dbf54856-9a98-4672-9c90-e9da71a1f893', 'john'),
    ('06b2ec25-3fe0-475e-9077-e77a113f4727', 'alice'),
    ('e6e84c46-6ddf-4d9a-b27a-ddb74b4d63bb', 'ashley'),
    ('8e99273f-e566-4476-836e-048b1ecd9c4d', 'megan'),
    ('1c309699-ca4f-43ed-84c6-8b924ef0b6eb', 'michael thompson'),
    ('ebc6d199-43ab-4d08-89e7-c5d8c4606fb9', 'will thompson');

COMMIT;


================================================================================
File: otel-collector-config.yaml
Size: 281 B
================================================================================

receivers:
  otlp:
    protocols:
      grpc:
        endpoint: "0.0.0.0:4317"

exporters:
  zipkin:
    endpoint: "http://zipkin:9411/api/v2/spans"

processors:
  batch:

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [zipkin]
